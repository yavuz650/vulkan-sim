// Copyright (c) 2009-2011, Tor M. Aamodt, Wilson W.L. Fung, George L. Yuan,
// Ali Bakhoda, Andrew Turner, Ivan Sham
// The University of British Columbia
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice, this
// list of conditions and the following disclaimer.
// Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution. Neither the name of
// The University of British Columbia nor the names of its contributors may be
// used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

#include "gpu-sim.h"

#include <math.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include "zlib.h"

#include "dram.h"
#include "mem_fetch.h"
#include "shader.h"
#include "shader_trace.h"

#include <time.h>
#include "addrdec.h"
#include "delayqueue.h"
#include "dram.h"
#include "gpu-cache.h"
#include "gpu-misc.h"
#include "icnt_wrapper.h"
#include "l2cache.h"
#include "shader.h"
#include "stat-tool.h"

#include "../../libcuda/gpgpu_context.h"
#include "../abstract_hardware_model.h"
#include "../cuda-sim/cuda-sim.h"
#include "../cuda-sim/cuda_device_runtime.h"
#include "../cuda-sim/ptx-stats.h"
#include "../cuda-sim/ptx_ir.h"
#include "../debug.h"
#include "../gpgpusim_entrypoint.h"
#include "../statwrapper.h"
#include "../trace.h"
#include "mem_latency_stat.h"
#include "power_stat.h"
#include "stats.h"
#include "visualizer.h"

#ifdef GPGPUSIM_POWER_MODEL
#include "power_interface.h"
#else
class gpgpu_sim_wrapper {};
#endif

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <sstream>
#include <string>
std::vector<int> cta_group_idx;// = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29};
int next_cta_group_idx;
std::vector<std::vector<int>> static_cta_schedule;

std::vector<std::vector<int>> cta_groups4 = {
  {0,4,8,12},
  {1,5,9,13},
  {2,6,10,14},
  {3,7,11,15},
  {16,20,24,28},
  {17,21,25,29},
  {18,22,26,30},
  {19,23,27,31},
  {32,36,40,44},
  {33,37,41,45},
  {34,38,42,46},
  {35,39,43,47},
  {48,52,56,60},
  {49,53,57,61},
  {50,54,58,62},
  {51,55,59,63},
  {64,68,72,76},
  {65,69,73,77},
  {66,70,74,78},
  {67,71,75,79},
  {80,84,88,92},
  {81,85,89,93},
  {82,86,90,94},
  {83,87,91,95},
  {96,100,104,108},
  {97,101,105,109},
  {98,102,106,110},
  {99,103,107,111},
  {112,116,120,124},
  {113,117,121,125},
  {114,118,122,126},
  {115,119,123,127},
  {128,132,136,140},
  {129,133,137,141},
  {130,134,138,142},
  {131,135,139,143},
  {144,148,152,156},
  {145,149,153,157},
  {146,150,154,158},
  {147,151,155,159},
  {160,164,168,172},
  {161,165,169,173},
  {162,166,170,174},
  {163,167,171,175},
  {176,180,184,188},
  {177,181,185,189},
  {178,182,186,190},
  {179,183,187,191},
  {192,196,200,204},
  {193,197,201,205},
  {194,198,202,206},
  {195,199,203,207},
  {208,212,216,220},
  {209,213,217,221},
  {210,214,218,222},
  {211,215,219,223},
  {224,228,232,236},
  {225,229,233,237},
  {226,230,234,238},
  {227,231,235,239},
  {240,244,248,252},
  {241,245,249,253},
  {242,246,250,254},
  {243,247,251,255},
  {256,260,264,268},
  {257,261,265,269},
  {258,262,266,270},
  {259,263,267,271},
  {272,276,280,284},
  {273,277,281,285},
  {274,278,282,286},
  {275,279,283,287},
  {288,292,296,300},
  {289,293,297,301},
  {290,294,298,302},
  {291,295,299,303},
  {304,308,312,316},
  {305,309,313,317},
  {306,310,314,318},
  {307,311,315,319},
  {320,324,328,332},
  {321,325,329,333},
  {322,326,330,334},
  {323,327,331,335},
  {336,340,344,348},
  {337,341,345,349},
  {338,342,346,350},
  {339,343,347,351},
  {352,356,360,364},
  {353,357,361,365},
  {354,358,362,366},
  {355,359,363,367},
  {368,372,376,380},
  {369,373,377,381},
  {370,374,378,382},
  {371,375,379,383},
  {384,388,392,396},
  {385,389,393,397},
  {386,390,394,398},
  {387,391,395,399},
  {400,404,408,412},
  {401,405,409,413},
  {402,406,410,414},
  {403,407,411,415},
  {416,420,424,428},
  {417,421,425,429},
  {418,422,426,430},
  {419,423,427,431},
  {432,436,440,444},
  {433,437,441,445},
  {434,438,442,446},
  {435,439,443,447},
  {448,452,456,460},
  {449,453,457,461},
  {450,454,458,462},
  {451,455,459,463},
  {464,468,472,476},
  {465,469,473,477},
  {466,470,474,478},
  {467,471,475,479},
  {480,484,488,492},
  {481,485,489,493},
  {482,486,490,494},
  {483,487,491,495},
  {496,500,504,508},
  {497,501,505,509},
  {498,502,506,510},
  {499,503,507,511},
  {512,516,520,524},
  {513,517,521,525},
  {514,518,522,526},
  {515,519,523,527},
  {528,532,536,540},
  {529,533,537,541},
  {530,534,538,542},
  {531,535,539,543},
  {544,548,552,556},
  {545,549,553,557},
  {546,550,554,558},
  {547,551,555,559},
  {560,564,568,572},
  {561,565,569,573},
  {562,566,570,574},
  {563,567,571,575},
  {576,580,584,588},
  {577,581,585,589},
  {578,582,586,590},
  {579,583,587,591},
  {592,596,600,604},
  {593,597,601,605},
  {594,598,602,606},
  {595,599,603,607},
  {608,612,616,620},
  {609,613,617,621},
  {610,614,618,622},
  {611,615,619,623},
  {624,628,632,636},
  {625,629,633,637},
  {626,630,634,638},
  {627,631,635,639},
  {640,644,648,652},
  {641,645,649,653},
  {642,646,650,654},
  {643,647,651,655},
  {656,660,664,668},
  {657,661,665,669},
  {658,662,666,670},
  {659,663,667,671},
  {672,676,680,684},
  {673,677,681,685},
  {674,678,682,686},
  {675,679,683,687},
  {688,692,696,700},
  {689,693,697,701},
  {690,694,698,702},
  {691,695,699,703},
  {704,708,712,716},
  {705,709,713,717},
  {706,710,714,718},
  {707,711,715,719},
  {720,724,728,732},
  {721,725,729,733},
  {722,726,730,734},
  {723,727,731,735},
  {736,740,744,748},
  {737,741,745,749},
  {738,742,746,750},
  {739,743,747,751},
  {752,756,760,764},
  {753,757,761,765},
  {754,758,762,766},
  {755,759,763,767},
  {768,772,776,780},
  {769,773,777,781},
  {770,774,778,782},
  {771,775,779,783},
  {784,788,792,796},
  {785,789,793,797},
  {786,790,794,798},
  {787,791,795,799},
  {800,804,808,812},
  {801,805,809,813},
  {802,806,810,814},
  {803,807,811,815},
  {816,820,824,828},
  {817,821,825,829},
  {818,822,826,830},
  {819,823,827,831},
  {832,836,840,844},
  {833,837,841,845},
  {834,838,842,846},
  {835,839,843,847},
  {848,852,856,860},
  {849,853,857,861},
  {850,854,858,862},
  {851,855,859,863},
  {864,868,872,876},
  {865,869,873,877},
  {866,870,874,878},
  {867,871,875,879},
  {880,884,888,892},
  {881,885,889,893},
  {882,886,890,894},
  {883,887,891,895},
  {896,900,904,908},
  {897,901,905,909},
  {898,902,906,910},
  {899,903,907,911},
  {912,916,920,924},
  {913,917,921,925},
  {914,918,922,926},
  {915,919,923,927},
  {928,932,936,940},
  {929,933,937,941},
  {930,934,938,942},
  {931,935,939,943},
  {944,948,952,956},
  {945,949,953,957},
  {946,950,954,958},
  {947,951,955,959},
  {960,964,968,972},
  {961,965,969,973},
  {962,966,970,974},
  {963,967,971,975},
  {976,980,984,988},
  {977,981,985,989},
  {978,982,986,990},
  {979,983,987,991},
  {992,996,1000,1004},
  {993,997,1001,1005},
  {994,998,1002,1006},
  {995,999,1003,1007},
  {1008,1012,1016,1020},
  {1009,1013,1017,1021},
  {1010,1014,1018,1022},
  {1011,1015,1019,1023}
};

std::vector<std::vector<int>> cta_groups8 = {
  {0, 4, 8, 12, 16, 20, 24, 28},
  {1, 5, 9, 13, 17, 21, 25, 29},
  {2, 6, 10, 14, 18, 22, 26, 30},
  {3, 7, 11, 15, 19, 23, 27, 31},
  {32, 36, 40, 44, 48, 52, 56, 60},
  {33, 37, 41, 45, 49, 53, 57, 61},
  {34, 38, 42, 46, 50, 54, 58, 62},
  {35, 39, 43, 47, 51, 55, 59, 63},
  {64, 68, 72, 76, 80, 84, 88, 92},
  {65, 69, 73, 77, 81, 85, 89, 93},
  {66, 70, 74, 78, 82, 86, 90, 94},
  {67, 71, 75, 79, 83, 87, 91, 95},
  {96, 100, 104, 108, 112, 116, 120, 124},
  {97, 101, 105, 109, 113, 117, 121, 125},
  {98, 102, 106, 110, 114, 118, 122, 126},
  {99, 103, 107, 111, 115, 119, 123, 127},
  {128, 132, 136, 140, 144, 148, 152, 156},
  {129, 133, 137, 141, 145, 149, 153, 157},
  {130, 134, 138, 142, 146, 150, 154, 158},
  {131, 135, 139, 143, 147, 151, 155, 159},
  {160, 164, 168, 172, 176, 180, 184, 188},
  {161, 165, 169, 173, 177, 181, 185, 189},
  {162, 166, 170, 174, 178, 182, 186, 190},
  {163, 167, 171, 175, 179, 183, 187, 191},
  {192, 196, 200, 204, 208, 212, 216, 220},
  {193, 197, 201, 205, 209, 213, 217, 221},
  {194, 198, 202, 206, 210, 214, 218, 222},
  {195, 199, 203, 207, 211, 215, 219, 223},
  {224, 228, 232, 236, 240, 244, 248, 252},
  {225, 229, 233, 237, 241, 245, 249, 253},
  {226, 230, 234, 238, 242, 246, 250, 254},
  {227, 231, 235, 239, 243, 247, 251, 255},
  {256, 260, 264, 268, 272, 276, 280, 284},
  {257, 261, 265, 269, 273, 277, 281, 285},
  {258, 262, 266, 270, 274, 278, 282, 286},
  {259, 263, 267, 271, 275, 279, 283, 287},
  {288, 292, 296, 300, 304, 308, 312, 316},
  {289, 293, 297, 301, 305, 309, 313, 317},
  {290, 294, 298, 302, 306, 310, 314, 318},
  {291, 295, 299, 303, 307, 311, 315, 319},
  {320, 324, 328, 332, 336, 340, 344, 348},
  {321, 325, 329, 333, 337, 341, 345, 349},
  {322, 326, 330, 334, 338, 342, 346, 350},
  {323, 327, 331, 335, 339, 343, 347, 351},
  {352, 356, 360, 364, 368, 372, 376, 380},
  {353, 357, 361, 365, 369, 373, 377, 381},
  {354, 358, 362, 366, 370, 374, 378, 382},
  {355, 359, 363, 367, 371, 375, 379, 383},
  {384, 388, 392, 396, 400, 404, 408, 412},
  {385, 389, 393, 397, 401, 405, 409, 413},
  {386, 390, 394, 398, 402, 406, 410, 414},
  {387, 391, 395, 399, 403, 407, 411, 415},
  {416, 420, 424, 428, 432, 436, 440, 444},
  {417, 421, 425, 429, 433, 437, 441, 445},
  {418, 422, 426, 430, 434, 438, 442, 446},
  {419, 423, 427, 431, 435, 439, 443, 447},
  {448, 452, 456, 460, 464, 468, 472, 476},
  {449, 453, 457, 461, 465, 469, 473, 477},
  {450, 454, 458, 462, 466, 470, 474, 478},
  {451, 455, 459, 463, 467, 471, 475, 479},
  {480, 484, 488, 492, 496, 500, 504, 508},
  {481, 485, 489, 493, 497, 501, 505, 509},
  {482, 486, 490, 494, 498, 502, 506, 510},
  {483, 487, 491, 495, 499, 503, 507, 511},
  {512, 516, 520, 524, 528, 532, 536, 540},
  {513, 517, 521, 525, 529, 533, 537, 541},
  {514, 518, 522, 526, 530, 534, 538, 542},
  {515, 519, 523, 527, 531, 535, 539, 543},
  {544, 548, 552, 556, 560, 564, 568, 572},
  {545, 549, 553, 557, 561, 565, 569, 573},
  {546, 550, 554, 558, 562, 566, 570, 574},
  {547, 551, 555, 559, 563, 567, 571, 575},
  {576, 580, 584, 588, 592, 596, 600, 604},
  {577, 581, 585, 589, 593, 597, 601, 605},
  {578, 582, 586, 590, 594, 598, 602, 606},
  {579, 583, 587, 591, 595, 599, 603, 607},
  {608, 612, 616, 620, 624, 628, 632, 636},
  {609, 613, 617, 621, 625, 629, 633, 637},
  {610, 614, 618, 622, 626, 630, 634, 638},
  {611, 615, 619, 623, 627, 631, 635, 639},
  {640, 644, 648, 652, 656, 660, 664, 668},
  {641, 645, 649, 653, 657, 661, 665, 669},
  {642, 646, 650, 654, 658, 662, 666, 670},
  {643, 647, 651, 655, 659, 663, 667, 671},
  {672, 676, 680, 684, 688, 692, 696, 700},
  {673, 677, 681, 685, 689, 693, 697, 701},
  {674, 678, 682, 686, 690, 694, 698, 702},
  {675, 679, 683, 687, 691, 695, 699, 703},
  {704, 708, 712, 716, 720, 724, 728, 732},
  {705, 709, 713, 717, 721, 725, 729, 733},
  {706, 710, 714, 718, 722, 726, 730, 734},
  {707, 711, 715, 719, 723, 727, 731, 735},
  {736, 740, 744, 748, 752, 756, 760, 764},
  {737, 741, 745, 749, 753, 757, 761, 765},
  {738, 742, 746, 750, 754, 758, 762, 766},
  {739, 743, 747, 751, 755, 759, 763, 767},
  {768, 772, 776, 780, 784, 788, 792, 796},
  {769, 773, 777, 781, 785, 789, 793, 797},
  {770, 774, 778, 782, 786, 790, 794, 798},
  {771, 775, 779, 783, 787, 791, 795, 799},
  {800, 804, 808, 812, 816, 820, 824, 828},
  {801, 805, 809, 813, 817, 821, 825, 829},
  {802, 806, 810, 814, 818, 822, 826, 830},
  {803, 807, 811, 815, 819, 823, 827, 831},
  {832, 836, 840, 844, 848, 852, 856, 860},
  {833, 837, 841, 845, 849, 853, 857, 861},
  {834, 838, 842, 846, 850, 854, 858, 862},
  {835, 839, 843, 847, 851, 855, 859, 863},
  {864, 868, 872, 876, 880, 884, 888, 892},
  {865, 869, 873, 877, 881, 885, 889, 893},
  {866, 870, 874, 878, 882, 886, 890, 894},
  {867, 871, 875, 879, 883, 887, 891, 895},
  {896, 900, 904, 908, 912, 916, 920, 924},
  {897, 901, 905, 909, 913, 917, 921, 925},
  {898, 902, 906, 910, 914, 918, 922, 926},
  {899, 903, 907, 911, 915, 919, 923, 927},
  {928, 932, 936, 940, 944, 948, 952, 956},
  {929, 933, 937, 941, 945, 949, 953, 957},
  {930, 934, 938, 942, 946, 950, 954, 958},
  {931, 935, 939, 943, 947, 951, 955, 959},
  {960, 964, 968, 972, 976, 980, 984, 988},
  {961, 965, 969, 973, 977, 981, 985, 989},
  {962, 966, 970, 974, 978, 982, 986, 990},
  {963, 967, 971, 975, 979, 983, 987, 991},
  {992, 996, 1000, 1004, 1008, 1012, 1016, 1020},
  {993, 997, 1001, 1005, 1009, 1013, 1017, 1021},
  {994, 998, 1002, 1006, 1010, 1014, 1018, 1022},
  {995, 999, 1003, 1007, 1011, 1015, 1019, 1023}
};

std::vector<std::vector<int>> cta_groups4_4096 = {
{0,8,16,24},
{1,9,17,25},
{2,10,18,26},
{3,11,19,27},
{4,12,20,28},
{5,13,21,29},
{6,14,22,30},
{7,15,23,31},
{32,40,48,56},
{33,41,49,57},
{34,42,50,58},
{35,43,51,59},
{36,44,52,60},
{37,45,53,61},
{38,46,54,62},
{39,47,55,63},
{64,72,80,88},
{65,73,81,89},
{66,74,82,90},
{67,75,83,91},
{68,76,84,92},
{69,77,85,93},
{70,78,86,94},
{71,79,87,95},
{96,104,112,120},
{97,105,113,121},
{98,106,114,122},
{99,107,115,123},
{100,108,116,124},
{101,109,117,125},
{102,110,118,126},
{103,111,119,127},
{128,136,144,152},
{129,137,145,153},
{130,138,146,154},
{131,139,147,155},
{132,140,148,156},
{133,141,149,157},
{134,142,150,158},
{135,143,151,159},
{160,168,176,184},
{161,169,177,185},
{162,170,178,186},
{163,171,179,187},
{164,172,180,188},
{165,173,181,189},
{166,174,182,190},
{167,175,183,191},
{192,200,208,216},
{193,201,209,217},
{194,202,210,218},
{195,203,211,219},
{196,204,212,220},
{197,205,213,221},
{198,206,214,222},
{199,207,215,223},
{224,232,240,248},
{225,233,241,249},
{226,234,242,250},
{227,235,243,251},
{228,236,244,252},
{229,237,245,253},
{230,238,246,254},
{231,239,247,255},
{256,264,272,280},
{257,265,273,281},
{258,266,274,282},
{259,267,275,283},
{260,268,276,284},
{261,269,277,285},
{262,270,278,286},
{263,271,279,287},
{288,296,304,312},
{289,297,305,313},
{290,298,306,314},
{291,299,307,315},
{292,300,308,316},
{293,301,309,317},
{294,302,310,318},
{295,303,311,319},
{320,328,336,344},
{321,329,337,345},
{322,330,338,346},
{323,331,339,347},
{324,332,340,348},
{325,333,341,349},
{326,334,342,350},
{327,335,343,351},
{352,360,368,376},
{353,361,369,377},
{354,362,370,378},
{355,363,371,379},
{356,364,372,380},
{357,365,373,381},
{358,366,374,382},
{359,367,375,383},
{384,392,400,408},
{385,393,401,409},
{386,394,402,410},
{387,395,403,411},
{388,396,404,412},
{389,397,405,413},
{390,398,406,414},
{391,399,407,415},
{416,424,432,440},
{417,425,433,441},
{418,426,434,442},
{419,427,435,443},
{420,428,436,444},
{421,429,437,445},
{422,430,438,446},
{423,431,439,447},
{448,456,464,472},
{449,457,465,473},
{450,458,466,474},
{451,459,467,475},
{452,460,468,476},
{453,461,469,477},
{454,462,470,478},
{455,463,471,479},
{480,488,496,504},
{481,489,497,505},
{482,490,498,506},
{483,491,499,507},
{484,492,500,508},
{485,493,501,509},
{486,494,502,510},
{487,495,503,511},
{512,520,528,536},
{513,521,529,537},
{514,522,530,538},
{515,523,531,539},
{516,524,532,540},
{517,525,533,541},
{518,526,534,542},
{519,527,535,543},
{544,552,560,568},
{545,553,561,569},
{546,554,562,570},
{547,555,563,571},
{548,556,564,572},
{549,557,565,573},
{550,558,566,574},
{551,559,567,575},
{576,584,592,600},
{577,585,593,601},
{578,586,594,602},
{579,587,595,603},
{580,588,596,604},
{581,589,597,605},
{582,590,598,606},
{583,591,599,607},
{608,616,624,632},
{609,617,625,633},
{610,618,626,634},
{611,619,627,635},
{612,620,628,636},
{613,621,629,637},
{614,622,630,638},
{615,623,631,639},
{640,648,656,664},
{641,649,657,665},
{642,650,658,666},
{643,651,659,667},
{644,652,660,668},
{645,653,661,669},
{646,654,662,670},
{647,655,663,671},
{672,680,688,696},
{673,681,689,697},
{674,682,690,698},
{675,683,691,699},
{676,684,692,700},
{677,685,693,701},
{678,686,694,702},
{679,687,695,703},
{704,712,720,728},
{705,713,721,729},
{706,714,722,730},
{707,715,723,731},
{708,716,724,732},
{709,717,725,733},
{710,718,726,734},
{711,719,727,735},
{736,744,752,760},
{737,745,753,761},
{738,746,754,762},
{739,747,755,763},
{740,748,756,764},
{741,749,757,765},
{742,750,758,766},
{743,751,759,767},
{768,776,784,792},
{769,777,785,793},
{770,778,786,794},
{771,779,787,795},
{772,780,788,796},
{773,781,789,797},
{774,782,790,798},
{775,783,791,799},
{800,808,816,824},
{801,809,817,825},
{802,810,818,826},
{803,811,819,827},
{804,812,820,828},
{805,813,821,829},
{806,814,822,830},
{807,815,823,831},
{832,840,848,856},
{833,841,849,857},
{834,842,850,858},
{835,843,851,859},
{836,844,852,860},
{837,845,853,861},
{838,846,854,862},
{839,847,855,863},
{864,872,880,888},
{865,873,881,889},
{866,874,882,890},
{867,875,883,891},
{868,876,884,892},
{869,877,885,893},
{870,878,886,894},
{871,879,887,895},
{896,904,912,920},
{897,905,913,921},
{898,906,914,922},
{899,907,915,923},
{900,908,916,924},
{901,909,917,925},
{902,910,918,926},
{903,911,919,927},
{928,936,944,952},
{929,937,945,953},
{930,938,946,954},
{931,939,947,955},
{932,940,948,956},
{933,941,949,957},
{934,942,950,958},
{935,943,951,959},
{960,968,976,984},
{961,969,977,985},
{962,970,978,986},
{963,971,979,987},
{964,972,980,988},
{965,973,981,989},
{966,974,982,990},
{967,975,983,991},
{992,1000,1008,1016},
{993,1001,1009,1017},
{994,1002,1010,1018},
{995,1003,1011,1019},
{996,1004,1012,1020},
{997,1005,1013,1021},
{998,1006,1014,1022},
{999,1007,1015,1023},
{1024,1032,1040,1048},
{1025,1033,1041,1049},
{1026,1034,1042,1050},
{1027,1035,1043,1051},
{1028,1036,1044,1052},
{1029,1037,1045,1053},
{1030,1038,1046,1054},
{1031,1039,1047,1055},
{1056,1064,1072,1080},
{1057,1065,1073,1081},
{1058,1066,1074,1082},
{1059,1067,1075,1083},
{1060,1068,1076,1084},
{1061,1069,1077,1085},
{1062,1070,1078,1086},
{1063,1071,1079,1087},
{1088,1096,1104,1112},
{1089,1097,1105,1113},
{1090,1098,1106,1114},
{1091,1099,1107,1115},
{1092,1100,1108,1116},
{1093,1101,1109,1117},
{1094,1102,1110,1118},
{1095,1103,1111,1119},
{1120,1128,1136,1144},
{1121,1129,1137,1145},
{1122,1130,1138,1146},
{1123,1131,1139,1147},
{1124,1132,1140,1148},
{1125,1133,1141,1149},
{1126,1134,1142,1150},
{1127,1135,1143,1151},
{1152,1160,1168,1176},
{1153,1161,1169,1177},
{1154,1162,1170,1178},
{1155,1163,1171,1179},
{1156,1164,1172,1180},
{1157,1165,1173,1181},
{1158,1166,1174,1182},
{1159,1167,1175,1183},
{1184,1192,1200,1208},
{1185,1193,1201,1209},
{1186,1194,1202,1210},
{1187,1195,1203,1211},
{1188,1196,1204,1212},
{1189,1197,1205,1213},
{1190,1198,1206,1214},
{1191,1199,1207,1215},
{1216,1224,1232,1240},
{1217,1225,1233,1241},
{1218,1226,1234,1242},
{1219,1227,1235,1243},
{1220,1228,1236,1244},
{1221,1229,1237,1245},
{1222,1230,1238,1246},
{1223,1231,1239,1247},
{1248,1256,1264,1272},
{1249,1257,1265,1273},
{1250,1258,1266,1274},
{1251,1259,1267,1275},
{1252,1260,1268,1276},
{1253,1261,1269,1277},
{1254,1262,1270,1278},
{1255,1263,1271,1279},
{1280,1288,1296,1304},
{1281,1289,1297,1305},
{1282,1290,1298,1306},
{1283,1291,1299,1307},
{1284,1292,1300,1308},
{1285,1293,1301,1309},
{1286,1294,1302,1310},
{1287,1295,1303,1311},
{1312,1320,1328,1336},
{1313,1321,1329,1337},
{1314,1322,1330,1338},
{1315,1323,1331,1339},
{1316,1324,1332,1340},
{1317,1325,1333,1341},
{1318,1326,1334,1342},
{1319,1327,1335,1343},
{1344,1352,1360,1368},
{1345,1353,1361,1369},
{1346,1354,1362,1370},
{1347,1355,1363,1371},
{1348,1356,1364,1372},
{1349,1357,1365,1373},
{1350,1358,1366,1374},
{1351,1359,1367,1375},
{1376,1384,1392,1400},
{1377,1385,1393,1401},
{1378,1386,1394,1402},
{1379,1387,1395,1403},
{1380,1388,1396,1404},
{1381,1389,1397,1405},
{1382,1390,1398,1406},
{1383,1391,1399,1407},
{1408,1416,1424,1432},
{1409,1417,1425,1433},
{1410,1418,1426,1434},
{1411,1419,1427,1435},
{1412,1420,1428,1436},
{1413,1421,1429,1437},
{1414,1422,1430,1438},
{1415,1423,1431,1439},
{1440,1448,1456,1464},
{1441,1449,1457,1465},
{1442,1450,1458,1466},
{1443,1451,1459,1467},
{1444,1452,1460,1468},
{1445,1453,1461,1469},
{1446,1454,1462,1470},
{1447,1455,1463,1471},
{1472,1480,1488,1496},
{1473,1481,1489,1497},
{1474,1482,1490,1498},
{1475,1483,1491,1499},
{1476,1484,1492,1500},
{1477,1485,1493,1501},
{1478,1486,1494,1502},
{1479,1487,1495,1503},
{1504,1512,1520,1528},
{1505,1513,1521,1529},
{1506,1514,1522,1530},
{1507,1515,1523,1531},
{1508,1516,1524,1532},
{1509,1517,1525,1533},
{1510,1518,1526,1534},
{1511,1519,1527,1535},
{1536,1544,1552,1560},
{1537,1545,1553,1561},
{1538,1546,1554,1562},
{1539,1547,1555,1563},
{1540,1548,1556,1564},
{1541,1549,1557,1565},
{1542,1550,1558,1566},
{1543,1551,1559,1567},
{1568,1576,1584,1592},
{1569,1577,1585,1593},
{1570,1578,1586,1594},
{1571,1579,1587,1595},
{1572,1580,1588,1596},
{1573,1581,1589,1597},
{1574,1582,1590,1598},
{1575,1583,1591,1599},
{1600,1608,1616,1624},
{1601,1609,1617,1625},
{1602,1610,1618,1626},
{1603,1611,1619,1627},
{1604,1612,1620,1628},
{1605,1613,1621,1629},
{1606,1614,1622,1630},
{1607,1615,1623,1631},
{1632,1640,1648,1656},
{1633,1641,1649,1657},
{1634,1642,1650,1658},
{1635,1643,1651,1659},
{1636,1644,1652,1660},
{1637,1645,1653,1661},
{1638,1646,1654,1662},
{1639,1647,1655,1663},
{1664,1672,1680,1688},
{1665,1673,1681,1689},
{1666,1674,1682,1690},
{1667,1675,1683,1691},
{1668,1676,1684,1692},
{1669,1677,1685,1693},
{1670,1678,1686,1694},
{1671,1679,1687,1695},
{1696,1704,1712,1720},
{1697,1705,1713,1721},
{1698,1706,1714,1722},
{1699,1707,1715,1723},
{1700,1708,1716,1724},
{1701,1709,1717,1725},
{1702,1710,1718,1726},
{1703,1711,1719,1727},
{1728,1736,1744,1752},
{1729,1737,1745,1753},
{1730,1738,1746,1754},
{1731,1739,1747,1755},
{1732,1740,1748,1756},
{1733,1741,1749,1757},
{1734,1742,1750,1758},
{1735,1743,1751,1759},
{1760,1768,1776,1784},
{1761,1769,1777,1785},
{1762,1770,1778,1786},
{1763,1771,1779,1787},
{1764,1772,1780,1788},
{1765,1773,1781,1789},
{1766,1774,1782,1790},
{1767,1775,1783,1791},
{1792,1800,1808,1816},
{1793,1801,1809,1817},
{1794,1802,1810,1818},
{1795,1803,1811,1819},
{1796,1804,1812,1820},
{1797,1805,1813,1821},
{1798,1806,1814,1822},
{1799,1807,1815,1823},
{1824,1832,1840,1848},
{1825,1833,1841,1849},
{1826,1834,1842,1850},
{1827,1835,1843,1851},
{1828,1836,1844,1852},
{1829,1837,1845,1853},
{1830,1838,1846,1854},
{1831,1839,1847,1855},
{1856,1864,1872,1880},
{1857,1865,1873,1881},
{1858,1866,1874,1882},
{1859,1867,1875,1883},
{1860,1868,1876,1884},
{1861,1869,1877,1885},
{1862,1870,1878,1886},
{1863,1871,1879,1887},
{1888,1896,1904,1912},
{1889,1897,1905,1913},
{1890,1898,1906,1914},
{1891,1899,1907,1915},
{1892,1900,1908,1916},
{1893,1901,1909,1917},
{1894,1902,1910,1918},
{1895,1903,1911,1919},
{1920,1928,1936,1944},
{1921,1929,1937,1945},
{1922,1930,1938,1946},
{1923,1931,1939,1947},
{1924,1932,1940,1948},
{1925,1933,1941,1949},
{1926,1934,1942,1950},
{1927,1935,1943,1951},
{1952,1960,1968,1976},
{1953,1961,1969,1977},
{1954,1962,1970,1978},
{1955,1963,1971,1979},
{1956,1964,1972,1980},
{1957,1965,1973,1981},
{1958,1966,1974,1982},
{1959,1967,1975,1983},
{1984,1992,2000,2008},
{1985,1993,2001,2009},
{1986,1994,2002,2010},
{1987,1995,2003,2011},
{1988,1996,2004,2012},
{1989,1997,2005,2013},
{1990,1998,2006,2014},
{1991,1999,2007,2015},
{2016,2024,2032,2040},
{2017,2025,2033,2041},
{2018,2026,2034,2042},
{2019,2027,2035,2043},
{2020,2028,2036,2044},
{2021,2029,2037,2045},
{2022,2030,2038,2046},
{2023,2031,2039,2047},
{2048,2056,2064,2072},
{2049,2057,2065,2073},
{2050,2058,2066,2074},
{2051,2059,2067,2075},
{2052,2060,2068,2076},
{2053,2061,2069,2077},
{2054,2062,2070,2078},
{2055,2063,2071,2079},
{2080,2088,2096,2104},
{2081,2089,2097,2105},
{2082,2090,2098,2106},
{2083,2091,2099,2107},
{2084,2092,2100,2108},
{2085,2093,2101,2109},
{2086,2094,2102,2110},
{2087,2095,2103,2111},
{2112,2120,2128,2136},
{2113,2121,2129,2137},
{2114,2122,2130,2138},
{2115,2123,2131,2139},
{2116,2124,2132,2140},
{2117,2125,2133,2141},
{2118,2126,2134,2142},
{2119,2127,2135,2143},
{2144,2152,2160,2168},
{2145,2153,2161,2169},
{2146,2154,2162,2170},
{2147,2155,2163,2171},
{2148,2156,2164,2172},
{2149,2157,2165,2173},
{2150,2158,2166,2174},
{2151,2159,2167,2175},
{2176,2184,2192,2200},
{2177,2185,2193,2201},
{2178,2186,2194,2202},
{2179,2187,2195,2203},
{2180,2188,2196,2204},
{2181,2189,2197,2205},
{2182,2190,2198,2206},
{2183,2191,2199,2207},
{2208,2216,2224,2232},
{2209,2217,2225,2233},
{2210,2218,2226,2234},
{2211,2219,2227,2235},
{2212,2220,2228,2236},
{2213,2221,2229,2237},
{2214,2222,2230,2238},
{2215,2223,2231,2239},
{2240,2248,2256,2264},
{2241,2249,2257,2265},
{2242,2250,2258,2266},
{2243,2251,2259,2267},
{2244,2252,2260,2268},
{2245,2253,2261,2269},
{2246,2254,2262,2270},
{2247,2255,2263,2271},
{2272,2280,2288,2296},
{2273,2281,2289,2297},
{2274,2282,2290,2298},
{2275,2283,2291,2299},
{2276,2284,2292,2300},
{2277,2285,2293,2301},
{2278,2286,2294,2302},
{2279,2287,2295,2303},
{2304,2312,2320,2328},
{2305,2313,2321,2329},
{2306,2314,2322,2330},
{2307,2315,2323,2331},
{2308,2316,2324,2332},
{2309,2317,2325,2333},
{2310,2318,2326,2334},
{2311,2319,2327,2335},
{2336,2344,2352,2360},
{2337,2345,2353,2361},
{2338,2346,2354,2362},
{2339,2347,2355,2363},
{2340,2348,2356,2364},
{2341,2349,2357,2365},
{2342,2350,2358,2366},
{2343,2351,2359,2367},
{2368,2376,2384,2392},
{2369,2377,2385,2393},
{2370,2378,2386,2394},
{2371,2379,2387,2395},
{2372,2380,2388,2396},
{2373,2381,2389,2397},
{2374,2382,2390,2398},
{2375,2383,2391,2399},
{2400,2408,2416,2424},
{2401,2409,2417,2425},
{2402,2410,2418,2426},
{2403,2411,2419,2427},
{2404,2412,2420,2428},
{2405,2413,2421,2429},
{2406,2414,2422,2430},
{2407,2415,2423,2431},
{2432,2440,2448,2456},
{2433,2441,2449,2457},
{2434,2442,2450,2458},
{2435,2443,2451,2459},
{2436,2444,2452,2460},
{2437,2445,2453,2461},
{2438,2446,2454,2462},
{2439,2447,2455,2463},
{2464,2472,2480,2488},
{2465,2473,2481,2489},
{2466,2474,2482,2490},
{2467,2475,2483,2491},
{2468,2476,2484,2492},
{2469,2477,2485,2493},
{2470,2478,2486,2494},
{2471,2479,2487,2495},
{2496,2504,2512,2520},
{2497,2505,2513,2521},
{2498,2506,2514,2522},
{2499,2507,2515,2523},
{2500,2508,2516,2524},
{2501,2509,2517,2525},
{2502,2510,2518,2526},
{2503,2511,2519,2527},
{2528,2536,2544,2552},
{2529,2537,2545,2553},
{2530,2538,2546,2554},
{2531,2539,2547,2555},
{2532,2540,2548,2556},
{2533,2541,2549,2557},
{2534,2542,2550,2558},
{2535,2543,2551,2559},
{2560,2568,2576,2584},
{2561,2569,2577,2585},
{2562,2570,2578,2586},
{2563,2571,2579,2587},
{2564,2572,2580,2588},
{2565,2573,2581,2589},
{2566,2574,2582,2590},
{2567,2575,2583,2591},
{2592,2600,2608,2616},
{2593,2601,2609,2617},
{2594,2602,2610,2618},
{2595,2603,2611,2619},
{2596,2604,2612,2620},
{2597,2605,2613,2621},
{2598,2606,2614,2622},
{2599,2607,2615,2623},
{2624,2632,2640,2648},
{2625,2633,2641,2649},
{2626,2634,2642,2650},
{2627,2635,2643,2651},
{2628,2636,2644,2652},
{2629,2637,2645,2653},
{2630,2638,2646,2654},
{2631,2639,2647,2655},
{2656,2664,2672,2680},
{2657,2665,2673,2681},
{2658,2666,2674,2682},
{2659,2667,2675,2683},
{2660,2668,2676,2684},
{2661,2669,2677,2685},
{2662,2670,2678,2686},
{2663,2671,2679,2687},
{2688,2696,2704,2712},
{2689,2697,2705,2713},
{2690,2698,2706,2714},
{2691,2699,2707,2715},
{2692,2700,2708,2716},
{2693,2701,2709,2717},
{2694,2702,2710,2718},
{2695,2703,2711,2719},
{2720,2728,2736,2744},
{2721,2729,2737,2745},
{2722,2730,2738,2746},
{2723,2731,2739,2747},
{2724,2732,2740,2748},
{2725,2733,2741,2749},
{2726,2734,2742,2750},
{2727,2735,2743,2751},
{2752,2760,2768,2776},
{2753,2761,2769,2777},
{2754,2762,2770,2778},
{2755,2763,2771,2779},
{2756,2764,2772,2780},
{2757,2765,2773,2781},
{2758,2766,2774,2782},
{2759,2767,2775,2783},
{2784,2792,2800,2808},
{2785,2793,2801,2809},
{2786,2794,2802,2810},
{2787,2795,2803,2811},
{2788,2796,2804,2812},
{2789,2797,2805,2813},
{2790,2798,2806,2814},
{2791,2799,2807,2815},
{2816,2824,2832,2840},
{2817,2825,2833,2841},
{2818,2826,2834,2842},
{2819,2827,2835,2843},
{2820,2828,2836,2844},
{2821,2829,2837,2845},
{2822,2830,2838,2846},
{2823,2831,2839,2847},
{2848,2856,2864,2872},
{2849,2857,2865,2873},
{2850,2858,2866,2874},
{2851,2859,2867,2875},
{2852,2860,2868,2876},
{2853,2861,2869,2877},
{2854,2862,2870,2878},
{2855,2863,2871,2879},
{2880,2888,2896,2904},
{2881,2889,2897,2905},
{2882,2890,2898,2906},
{2883,2891,2899,2907},
{2884,2892,2900,2908},
{2885,2893,2901,2909},
{2886,2894,2902,2910},
{2887,2895,2903,2911},
{2912,2920,2928,2936},
{2913,2921,2929,2937},
{2914,2922,2930,2938},
{2915,2923,2931,2939},
{2916,2924,2932,2940},
{2917,2925,2933,2941},
{2918,2926,2934,2942},
{2919,2927,2935,2943},
{2944,2952,2960,2968},
{2945,2953,2961,2969},
{2946,2954,2962,2970},
{2947,2955,2963,2971},
{2948,2956,2964,2972},
{2949,2957,2965,2973},
{2950,2958,2966,2974},
{2951,2959,2967,2975},
{2976,2984,2992,3000},
{2977,2985,2993,3001},
{2978,2986,2994,3002},
{2979,2987,2995,3003},
{2980,2988,2996,3004},
{2981,2989,2997,3005},
{2982,2990,2998,3006},
{2983,2991,2999,3007},
{3008,3016,3024,3032},
{3009,3017,3025,3033},
{3010,3018,3026,3034},
{3011,3019,3027,3035},
{3012,3020,3028,3036},
{3013,3021,3029,3037},
{3014,3022,3030,3038},
{3015,3023,3031,3039},
{3040,3048,3056,3064},
{3041,3049,3057,3065},
{3042,3050,3058,3066},
{3043,3051,3059,3067},
{3044,3052,3060,3068},
{3045,3053,3061,3069},
{3046,3054,3062,3070},
{3047,3055,3063,3071},
{3072,3080,3088,3096},
{3073,3081,3089,3097},
{3074,3082,3090,3098},
{3075,3083,3091,3099},
{3076,3084,3092,3100},
{3077,3085,3093,3101},
{3078,3086,3094,3102},
{3079,3087,3095,3103},
{3104,3112,3120,3128},
{3105,3113,3121,3129},
{3106,3114,3122,3130},
{3107,3115,3123,3131},
{3108,3116,3124,3132},
{3109,3117,3125,3133},
{3110,3118,3126,3134},
{3111,3119,3127,3135},
{3136,3144,3152,3160},
{3137,3145,3153,3161},
{3138,3146,3154,3162},
{3139,3147,3155,3163},
{3140,3148,3156,3164},
{3141,3149,3157,3165},
{3142,3150,3158,3166},
{3143,3151,3159,3167},
{3168,3176,3184,3192},
{3169,3177,3185,3193},
{3170,3178,3186,3194},
{3171,3179,3187,3195},
{3172,3180,3188,3196},
{3173,3181,3189,3197},
{3174,3182,3190,3198},
{3175,3183,3191,3199},
{3200,3208,3216,3224},
{3201,3209,3217,3225},
{3202,3210,3218,3226},
{3203,3211,3219,3227},
{3204,3212,3220,3228},
{3205,3213,3221,3229},
{3206,3214,3222,3230},
{3207,3215,3223,3231},
{3232,3240,3248,3256},
{3233,3241,3249,3257},
{3234,3242,3250,3258},
{3235,3243,3251,3259},
{3236,3244,3252,3260},
{3237,3245,3253,3261},
{3238,3246,3254,3262},
{3239,3247,3255,3263},
{3264,3272,3280,3288},
{3265,3273,3281,3289},
{3266,3274,3282,3290},
{3267,3275,3283,3291},
{3268,3276,3284,3292},
{3269,3277,3285,3293},
{3270,3278,3286,3294},
{3271,3279,3287,3295},
{3296,3304,3312,3320},
{3297,3305,3313,3321},
{3298,3306,3314,3322},
{3299,3307,3315,3323},
{3300,3308,3316,3324},
{3301,3309,3317,3325},
{3302,3310,3318,3326},
{3303,3311,3319,3327},
{3328,3336,3344,3352},
{3329,3337,3345,3353},
{3330,3338,3346,3354},
{3331,3339,3347,3355},
{3332,3340,3348,3356},
{3333,3341,3349,3357},
{3334,3342,3350,3358},
{3335,3343,3351,3359},
{3360,3368,3376,3384},
{3361,3369,3377,3385},
{3362,3370,3378,3386},
{3363,3371,3379,3387},
{3364,3372,3380,3388},
{3365,3373,3381,3389},
{3366,3374,3382,3390},
{3367,3375,3383,3391},
{3392,3400,3408,3416},
{3393,3401,3409,3417},
{3394,3402,3410,3418},
{3395,3403,3411,3419},
{3396,3404,3412,3420},
{3397,3405,3413,3421},
{3398,3406,3414,3422},
{3399,3407,3415,3423},
{3424,3432,3440,3448},
{3425,3433,3441,3449},
{3426,3434,3442,3450},
{3427,3435,3443,3451},
{3428,3436,3444,3452},
{3429,3437,3445,3453},
{3430,3438,3446,3454},
{3431,3439,3447,3455},
{3456,3464,3472,3480},
{3457,3465,3473,3481},
{3458,3466,3474,3482},
{3459,3467,3475,3483},
{3460,3468,3476,3484},
{3461,3469,3477,3485},
{3462,3470,3478,3486},
{3463,3471,3479,3487},
{3488,3496,3504,3512},
{3489,3497,3505,3513},
{3490,3498,3506,3514},
{3491,3499,3507,3515},
{3492,3500,3508,3516},
{3493,3501,3509,3517},
{3494,3502,3510,3518},
{3495,3503,3511,3519},
{3520,3528,3536,3544},
{3521,3529,3537,3545},
{3522,3530,3538,3546},
{3523,3531,3539,3547},
{3524,3532,3540,3548},
{3525,3533,3541,3549},
{3526,3534,3542,3550},
{3527,3535,3543,3551},
{3552,3560,3568,3576},
{3553,3561,3569,3577},
{3554,3562,3570,3578},
{3555,3563,3571,3579},
{3556,3564,3572,3580},
{3557,3565,3573,3581},
{3558,3566,3574,3582},
{3559,3567,3575,3583},
{3584,3592,3600,3608},
{3585,3593,3601,3609},
{3586,3594,3602,3610},
{3587,3595,3603,3611},
{3588,3596,3604,3612},
{3589,3597,3605,3613},
{3590,3598,3606,3614},
{3591,3599,3607,3615},
{3616,3624,3632,3640},
{3617,3625,3633,3641},
{3618,3626,3634,3642},
{3619,3627,3635,3643},
{3620,3628,3636,3644},
{3621,3629,3637,3645},
{3622,3630,3638,3646},
{3623,3631,3639,3647},
{3648,3656,3664,3672},
{3649,3657,3665,3673},
{3650,3658,3666,3674},
{3651,3659,3667,3675},
{3652,3660,3668,3676},
{3653,3661,3669,3677},
{3654,3662,3670,3678},
{3655,3663,3671,3679},
{3680,3688,3696,3704},
{3681,3689,3697,3705},
{3682,3690,3698,3706},
{3683,3691,3699,3707},
{3684,3692,3700,3708},
{3685,3693,3701,3709},
{3686,3694,3702,3710},
{3687,3695,3703,3711},
{3712,3720,3728,3736},
{3713,3721,3729,3737},
{3714,3722,3730,3738},
{3715,3723,3731,3739},
{3716,3724,3732,3740},
{3717,3725,3733,3741},
{3718,3726,3734,3742},
{3719,3727,3735,3743},
{3744,3752,3760,3768},
{3745,3753,3761,3769},
{3746,3754,3762,3770},
{3747,3755,3763,3771},
{3748,3756,3764,3772},
{3749,3757,3765,3773},
{3750,3758,3766,3774},
{3751,3759,3767,3775},
{3776,3784,3792,3800},
{3777,3785,3793,3801},
{3778,3786,3794,3802},
{3779,3787,3795,3803},
{3780,3788,3796,3804},
{3781,3789,3797,3805},
{3782,3790,3798,3806},
{3783,3791,3799,3807},
{3808,3816,3824,3832},
{3809,3817,3825,3833},
{3810,3818,3826,3834},
{3811,3819,3827,3835},
{3812,3820,3828,3836},
{3813,3821,3829,3837},
{3814,3822,3830,3838},
{3815,3823,3831,3839},
{3840,3848,3856,3864},
{3841,3849,3857,3865},
{3842,3850,3858,3866},
{3843,3851,3859,3867},
{3844,3852,3860,3868},
{3845,3853,3861,3869},
{3846,3854,3862,3870},
{3847,3855,3863,3871},
{3872,3880,3888,3896},
{3873,3881,3889,3897},
{3874,3882,3890,3898},
{3875,3883,3891,3899},
{3876,3884,3892,3900},
{3877,3885,3893,3901},
{3878,3886,3894,3902},
{3879,3887,3895,3903},
{3904,3912,3920,3928},
{3905,3913,3921,3929},
{3906,3914,3922,3930},
{3907,3915,3923,3931},
{3908,3916,3924,3932},
{3909,3917,3925,3933},
{3910,3918,3926,3934},
{3911,3919,3927,3935},
{3936,3944,3952,3960},
{3937,3945,3953,3961},
{3938,3946,3954,3962},
{3939,3947,3955,3963},
{3940,3948,3956,3964},
{3941,3949,3957,3965},
{3942,3950,3958,3966},
{3943,3951,3959,3967},
{3968,3976,3984,3992},
{3969,3977,3985,3993},
{3970,3978,3986,3994},
{3971,3979,3987,3995},
{3972,3980,3988,3996},
{3973,3981,3989,3997},
{3974,3982,3990,3998},
{3975,3983,3991,3999},
{4000,4008,4016,4024},
{4001,4009,4017,4025},
{4002,4010,4018,4026},
{4003,4011,4019,4027},
{4004,4012,4020,4028},
{4005,4013,4021,4029},
{4006,4014,4022,4030},
{4007,4015,4023,4031},
{4032,4040,4048,4056},
{4033,4041,4049,4057},
{4034,4042,4050,4058},
{4035,4043,4051,4059},
{4036,4044,4052,4060},
{4037,4045,4053,4061},
{4038,4046,4054,4062},
{4039,4047,4055,4063},
{4064,4072,4080,4088},
{4065,4073,4081,4089},
{4066,4074,4082,4090},
{4067,4075,4083,4091},
{4068,4076,4084,4092},
{4069,4077,4085,4093},
{4070,4078,4086,4094},
{4071,4079,4087,4095}};

std::vector<std::vector<int>> cta_groups4_8x4 = {
{0,16,32,48},
{1,17,33,49},
{2,18,34,50},
{3,19,35,51},
{4,20,36,52},
{5,21,37,53},
{6,22,38,54},
{7,23,39,55},
{8,24,40,56},
{9,25,41,57},
{10,26,42,58},
{11,27,43,59},
{12,28,44,60},
{13,29,45,61},
{14,30,46,62},
{15,31,47,63},
{64,80,96,112},
{65,81,97,113},
{66,82,98,114},
{67,83,99,115},
{68,84,100,116},
{69,85,101,117},
{70,86,102,118},
{71,87,103,119},
{72,88,104,120},
{73,89,105,121},
{74,90,106,122},
{75,91,107,123},
{76,92,108,124},
{77,93,109,125},
{78,94,110,126},
{79,95,111,127},
{128,144,160,176},
{129,145,161,177},
{130,146,162,178},
{131,147,163,179},
{132,148,164,180},
{133,149,165,181},
{134,150,166,182},
{135,151,167,183},
{136,152,168,184},
{137,153,169,185},
{138,154,170,186},
{139,155,171,187},
{140,156,172,188},
{141,157,173,189},
{142,158,174,190},
{143,159,175,191},
{192,208,224,240},
{193,209,225,241},
{194,210,226,242},
{195,211,227,243},
{196,212,228,244},
{197,213,229,245},
{198,214,230,246},
{199,215,231,247},
{200,216,232,248},
{201,217,233,249},
{202,218,234,250},
{203,219,235,251},
{204,220,236,252},
{205,221,237,253},
{206,222,238,254},
{207,223,239,255},
{256,272,288,304},
{257,273,289,305},
{258,274,290,306},
{259,275,291,307},
{260,276,292,308},
{261,277,293,309},
{262,278,294,310},
{263,279,295,311},
{264,280,296,312},
{265,281,297,313},
{266,282,298,314},
{267,283,299,315},
{268,284,300,316},
{269,285,301,317},
{270,286,302,318},
{271,287,303,319},
{320,336,352,368},
{321,337,353,369},
{322,338,354,370},
{323,339,355,371},
{324,340,356,372},
{325,341,357,373},
{326,342,358,374},
{327,343,359,375},
{328,344,360,376},
{329,345,361,377},
{330,346,362,378},
{331,347,363,379},
{332,348,364,380},
{333,349,365,381},
{334,350,366,382},
{335,351,367,383},
{384,400,416,432},
{385,401,417,433},
{386,402,418,434},
{387,403,419,435},
{388,404,420,436},
{389,405,421,437},
{390,406,422,438},
{391,407,423,439},
{392,408,424,440},
{393,409,425,441},
{394,410,426,442},
{395,411,427,443},
{396,412,428,444},
{397,413,429,445},
{398,414,430,446},
{399,415,431,447},
{448,464,480,496},
{449,465,481,497},
{450,466,482,498},
{451,467,483,499},
{452,468,484,500},
{453,469,485,501},
{454,470,486,502},
{455,471,487,503},
{456,472,488,504},
{457,473,489,505},
{458,474,490,506},
{459,475,491,507},
{460,476,492,508},
{461,477,493,509},
{462,478,494,510},
{463,479,495,511},
{512,528,544,560},
{513,529,545,561},
{514,530,546,562},
{515,531,547,563},
{516,532,548,564},
{517,533,549,565},
{518,534,550,566},
{519,535,551,567},
{520,536,552,568},
{521,537,553,569},
{522,538,554,570},
{523,539,555,571},
{524,540,556,572},
{525,541,557,573},
{526,542,558,574},
{527,543,559,575},
{576,592,608,624},
{577,593,609,625},
{578,594,610,626},
{579,595,611,627},
{580,596,612,628},
{581,597,613,629},
{582,598,614,630},
{583,599,615,631},
{584,600,616,632},
{585,601,617,633},
{586,602,618,634},
{587,603,619,635},
{588,604,620,636},
{589,605,621,637},
{590,606,622,638},
{591,607,623,639},
{640,656,672,688},
{641,657,673,689},
{642,658,674,690},
{643,659,675,691},
{644,660,676,692},
{645,661,677,693},
{646,662,678,694},
{647,663,679,695},
{648,664,680,696},
{649,665,681,697},
{650,666,682,698},
{651,667,683,699},
{652,668,684,700},
{653,669,685,701},
{654,670,686,702},
{655,671,687,703},
{704,720,736,752},
{705,721,737,753},
{706,722,738,754},
{707,723,739,755},
{708,724,740,756},
{709,725,741,757},
{710,726,742,758},
{711,727,743,759},
{712,728,744,760},
{713,729,745,761},
{714,730,746,762},
{715,731,747,763},
{716,732,748,764},
{717,733,749,765},
{718,734,750,766},
{719,735,751,767},
{768,784,800,816},
{769,785,801,817},
{770,786,802,818},
{771,787,803,819},
{772,788,804,820},
{773,789,805,821},
{774,790,806,822},
{775,791,807,823},
{776,792,808,824},
{777,793,809,825},
{778,794,810,826},
{779,795,811,827},
{780,796,812,828},
{781,797,813,829},
{782,798,814,830},
{783,799,815,831},
{832,848,864,880},
{833,849,865,881},
{834,850,866,882},
{835,851,867,883},
{836,852,868,884},
{837,853,869,885},
{838,854,870,886},
{839,855,871,887},
{840,856,872,888},
{841,857,873,889},
{842,858,874,890},
{843,859,875,891},
{844,860,876,892},
{845,861,877,893},
{846,862,878,894},
{847,863,879,895},
{896,912,928,944},
{897,913,929,945},
{898,914,930,946},
{899,915,931,947},
{900,916,932,948},
{901,917,933,949},
{902,918,934,950},
{903,919,935,951},
{904,920,936,952},
{905,921,937,953},
{906,922,938,954},
{907,923,939,955},
{908,924,940,956},
{909,925,941,957},
{910,926,942,958},
{911,927,943,959},
{960,976,992,1008},
{961,977,993,1009},
{962,978,994,1010},
{963,979,995,1011},
{964,980,996,1012},
{965,981,997,1013},
{966,982,998,1014},
{967,983,999,1015},
{968,984,1000,1016},
{969,985,1001,1017},
{970,986,1002,1018},
{971,987,1003,1019},
{972,988,1004,1020},
{973,989,1005,1021},
{974,990,1006,1022},
{975,991,1007,1023}};

std::vector<std::vector<int>> cta_groups4_interleaved1 = { 
{0,16,32,48},
{1,17,33,49},
{2,18,34,50},
{3,19,35,51},
{4,20,36,52},
{5,21,37,53},
{6,22,38,54},
{7,23,39,55},
{8,24,40,56},
{9,25,41,57},
{10,26,42,58},
{11,27,43,59},
{12,28,44,60},
{13,29,45,61},
{14,30,46,62},
{15,31,47,63},
{64,80,96,112},
{65,81,97,113},
{66,82,98,114},
{67,83,99,115},
{68,84,100,116},
{69,85,101,117},
{70,86,102,118},
{71,87,103,119},
{72,88,104,120},
{73,89,105,121},
{74,90,106,122},
{75,91,107,123},
{76,92,108,124},
{77,93,109,125},
{78,94,110,126},
{79,95,111,127},
{128,144,160,176},
{129,145,161,177},
{130,146,162,178},
{131,147,163,179},
{132,148,164,180},
{133,149,165,181},
{134,150,166,182},
{135,151,167,183},
{136,152,168,184},
{137,153,169,185},
{138,154,170,186},
{139,155,171,187},
{140,156,172,188},
{141,157,173,189},
{142,158,174,190},
{143,159,175,191},
{192,208,224,240},
{193,209,225,241},
{194,210,226,242},
{195,211,227,243},
{196,212,228,244},
{197,213,229,245},
{198,214,230,246},
{199,215,231,247},
{200,216,232,248},
{201,217,233,249},
{202,218,234,250},
{203,219,235,251},
{204,220,236,252},
{205,221,237,253},
{206,222,238,254},
{207,223,239,255},
{256,272,288,304},
{257,273,289,305},
{258,274,290,306},
{259,275,291,307},
{260,276,292,308},
{261,277,293,309},
{262,278,294,310},
{263,279,295,311},
{264,280,296,312},
{265,281,297,313},
{266,282,298,314},
{267,283,299,315},
{268,284,300,316},
{269,285,301,317},
{270,286,302,318},
{271,287,303,319},
{320,336,352,368},
{321,337,353,369},
{322,338,354,370},
{323,339,355,371},
{324,340,356,372},
{325,341,357,373},
{326,342,358,374},
{327,343,359,375},
{328,344,360,376},
{329,345,361,377},
{330,346,362,378},
{331,347,363,379},
{332,348,364,380},
{333,349,365,381},
{334,350,366,382},
{335,351,367,383},
{384,400,416,432},
{385,401,417,433},
{386,402,418,434},
{387,403,419,435},
{388,404,420,436},
{389,405,421,437},
{390,406,422,438},
{391,407,423,439},
{392,408,424,440},
{393,409,425,441},
{394,410,426,442},
{395,411,427,443},
{396,412,428,444},
{397,413,429,445},
{398,414,430,446},
{399,415,431,447},
{448,464,480,496},
{449,465,481,497},
{450,466,482,498},
{451,467,483,499},
{452,468,484,500},
{453,469,485,501},
{454,470,486,502},
{455,471,487,503},
{456,472,488,504},
{457,473,489,505},
{458,474,490,506},
{459,475,491,507},
{460,476,492,508},
{461,477,493,509},
{462,478,494,510},
{463,479,495,511},
{512,528,544,560},
{513,529,545,561},
{514,530,546,562},
{515,531,547,563},
{516,532,548,564},
{517,533,549,565},
{518,534,550,566},
{519,535,551,567},
{520,536,552,568},
{521,537,553,569},
{522,538,554,570},
{523,539,555,571},
{524,540,556,572},
{525,541,557,573},
{526,542,558,574},
{527,543,559,575},
{576,592,608,624},
{577,593,609,625},
{578,594,610,626},
{579,595,611,627},
{580,596,612,628},
{581,597,613,629},
{582,598,614,630},
{583,599,615,631},
{584,600,616,632},
{585,601,617,633},
{586,602,618,634},
{587,603,619,635},
{588,604,620,636},
{589,605,621,637},
{590,606,622,638},
{591,607,623,639},
{640,656,672,688},
{641,657,673,689},
{642,658,674,690},
{643,659,675,691},
{644,660,676,692},
{645,661,677,693},
{646,662,678,694},
{647,663,679,695},
{648,664,680,696},
{649,665,681,697},
{650,666,682,698},
{651,667,683,699},
{652,668,684,700},
{653,669,685,701},
{654,670,686,702},
{655,671,687,703},
{704,720,736,752},
{705,721,737,753},
{706,722,738,754},
{707,723,739,755},
{708,724,740,756},
{709,725,741,757},
{710,726,742,758},
{711,727,743,759},
{712,728,744,760},
{713,729,745,761},
{714,730,746,762},
{715,731,747,763},
{716,732,748,764},
{717,733,749,765},
{718,734,750,766},
{719,735,751,767},
{768,784,800,816},
{769,785,801,817},
{770,786,802,818},
{771,787,803,819},
{772,788,804,820},
{773,789,805,821},
{774,790,806,822},
{775,791,807,823},
{776,792,808,824},
{777,793,809,825},
{778,794,810,826},
{779,795,811,827},
{780,796,812,828},
{781,797,813,829},
{782,798,814,830},
{783,799,815,831},
{832,848,864,880},
{833,849,865,881},
{834,850,866,882},
{835,851,867,883},
{836,852,868,884},
{837,853,869,885},
{838,854,870,886},
{839,855,871,887},
{840,856,872,888},
{841,857,873,889},
{842,858,874,890},
{843,859,875,891},
{844,860,876,892},
{845,861,877,893},
{846,862,878,894},
{847,863,879,895},
{896,912,928,944},
{897,913,929,945},
{898,914,930,946},
{899,915,931,947},
{900,916,932,948},
{901,917,933,949},
{902,918,934,950},
{903,919,935,951},
{904,920,936,952},
{905,921,937,953},
{906,922,938,954},
{907,923,939,955},
{908,924,940,956},
{909,925,941,957},
{910,926,942,958},
{911,927,943,959},
{960,976,992,1008},
{961,977,993,1009},
{962,978,994,1010},
{963,979,995,1011},
{964,980,996,1012},
{965,981,997,1013},
{966,982,998,1014},
{967,983,999,1015},
{968,984,1000,1016},
{969,985,1001,1017},
{970,986,1002,1018},
{971,987,1003,1019},
{972,988,1004,1020},
{973,989,1005,1021},
{974,990,1006,1022},
{975,991,1007,1023},
{1024,1040,1056,1072},
{1025,1041,1057,1073},
{1026,1042,1058,1074},
{1027,1043,1059,1075},
{1028,1044,1060,1076},
{1029,1045,1061,1077},
{1030,1046,1062,1078},
{1031,1047,1063,1079},
{1032,1048,1064,1080},
{1033,1049,1065,1081},
{1034,1050,1066,1082},
{1035,1051,1067,1083},
{1036,1052,1068,1084},
{1037,1053,1069,1085},
{1038,1054,1070,1086},
{1039,1055,1071,1087},
{1088,1104,1120,1136},
{1089,1105,1121,1137},
{1090,1106,1122,1138},
{1091,1107,1123,1139},
{1092,1108,1124,1140},
{1093,1109,1125,1141},
{1094,1110,1126,1142},
{1095,1111,1127,1143},
{1096,1112,1128,1144},
{1097,1113,1129,1145},
{1098,1114,1130,1146},
{1099,1115,1131,1147},
{1100,1116,1132,1148},
{1101,1117,1133,1149},
{1102,1118,1134,1150},
{1103,1119,1135,1151},
{1152,1168,1184,1200},
{1153,1169,1185,1201},
{1154,1170,1186,1202},
{1155,1171,1187,1203},
{1156,1172,1188,1204},
{1157,1173,1189,1205},
{1158,1174,1190,1206},
{1159,1175,1191,1207},
{1160,1176,1192,1208},
{1161,1177,1193,1209},
{1162,1178,1194,1210},
{1163,1179,1195,1211},
{1164,1180,1196,1212},
{1165,1181,1197,1213},
{1166,1182,1198,1214},
{1167,1183,1199,1215},
{1216,1232,1248,1264},
{1217,1233,1249,1265},
{1218,1234,1250,1266},
{1219,1235,1251,1267},
{1220,1236,1252,1268},
{1221,1237,1253,1269},
{1222,1238,1254,1270},
{1223,1239,1255,1271},
{1224,1240,1256,1272},
{1225,1241,1257,1273},
{1226,1242,1258,1274},
{1227,1243,1259,1275},
{1228,1244,1260,1276},
{1229,1245,1261,1277},
{1230,1246,1262,1278},
{1231,1247,1263,1279},
{1280,1296,1312,1328},
{1281,1297,1313,1329},
{1282,1298,1314,1330},
{1283,1299,1315,1331},
{1284,1300,1316,1332},
{1285,1301,1317,1333},
{1286,1302,1318,1334},
{1287,1303,1319,1335},
{1288,1304,1320,1336},
{1289,1305,1321,1337},
{1290,1306,1322,1338},
{1291,1307,1323,1339},
{1292,1308,1324,1340},
{1293,1309,1325,1341},
{1294,1310,1326,1342},
{1295,1311,1327,1343},
{1344,1360,1376,1392},
{1345,1361,1377,1393},
{1346,1362,1378,1394},
{1347,1363,1379,1395},
{1348,1364,1380,1396},
{1349,1365,1381,1397},
{1350,1366,1382,1398},
{1351,1367,1383,1399},
{1352,1368,1384,1400},
{1353,1369,1385,1401},
{1354,1370,1386,1402},
{1355,1371,1387,1403},
{1356,1372,1388,1404},
{1357,1373,1389,1405},
{1358,1374,1390,1406},
{1359,1375,1391,1407},
{1408,1424,1440,1456},
{1409,1425,1441,1457},
{1410,1426,1442,1458},
{1411,1427,1443,1459},
{1412,1428,1444,1460},
{1413,1429,1445,1461},
{1414,1430,1446,1462},
{1415,1431,1447,1463},
{1416,1432,1448,1464},
{1417,1433,1449,1465},
{1418,1434,1450,1466},
{1419,1435,1451,1467},
{1420,1436,1452,1468},
{1421,1437,1453,1469},
{1422,1438,1454,1470},
{1423,1439,1455,1471},
{1472,1488,1504,1520},
{1473,1489,1505,1521},
{1474,1490,1506,1522},
{1475,1491,1507,1523},
{1476,1492,1508,1524},
{1477,1493,1509,1525},
{1478,1494,1510,1526},
{1479,1495,1511,1527},
{1480,1496,1512,1528},
{1481,1497,1513,1529},
{1482,1498,1514,1530},
{1483,1499,1515,1531},
{1484,1500,1516,1532},
{1485,1501,1517,1533},
{1486,1502,1518,1534},
{1487,1503,1519,1535},
{1536,1552,1568,1584},
{1537,1553,1569,1585},
{1538,1554,1570,1586},
{1539,1555,1571,1587},
{1540,1556,1572,1588},
{1541,1557,1573,1589},
{1542,1558,1574,1590},
{1543,1559,1575,1591},
{1544,1560,1576,1592},
{1545,1561,1577,1593},
{1546,1562,1578,1594},
{1547,1563,1579,1595},
{1548,1564,1580,1596},
{1549,1565,1581,1597},
{1550,1566,1582,1598},
{1551,1567,1583,1599},
{1600,1616,1632,1648},
{1601,1617,1633,1649},
{1602,1618,1634,1650},
{1603,1619,1635,1651},
{1604,1620,1636,1652},
{1605,1621,1637,1653},
{1606,1622,1638,1654},
{1607,1623,1639,1655},
{1608,1624,1640,1656},
{1609,1625,1641,1657},
{1610,1626,1642,1658},
{1611,1627,1643,1659},
{1612,1628,1644,1660},
{1613,1629,1645,1661},
{1614,1630,1646,1662},
{1615,1631,1647,1663},
{1664,1680,1696,1712},
{1665,1681,1697,1713},
{1666,1682,1698,1714},
{1667,1683,1699,1715},
{1668,1684,1700,1716},
{1669,1685,1701,1717},
{1670,1686,1702,1718},
{1671,1687,1703,1719},
{1672,1688,1704,1720},
{1673,1689,1705,1721},
{1674,1690,1706,1722},
{1675,1691,1707,1723},
{1676,1692,1708,1724},
{1677,1693,1709,1725},
{1678,1694,1710,1726},
{1679,1695,1711,1727},
{1728,1744,1760,1776},
{1729,1745,1761,1777},
{1730,1746,1762,1778},
{1731,1747,1763,1779},
{1732,1748,1764,1780},
{1733,1749,1765,1781},
{1734,1750,1766,1782},
{1735,1751,1767,1783},
{1736,1752,1768,1784},
{1737,1753,1769,1785},
{1738,1754,1770,1786},
{1739,1755,1771,1787},
{1740,1756,1772,1788},
{1741,1757,1773,1789},
{1742,1758,1774,1790},
{1743,1759,1775,1791},
{1792,1808,1824,1840},
{1793,1809,1825,1841},
{1794,1810,1826,1842},
{1795,1811,1827,1843},
{1796,1812,1828,1844},
{1797,1813,1829,1845},
{1798,1814,1830,1846},
{1799,1815,1831,1847},
{1800,1816,1832,1848},
{1801,1817,1833,1849},
{1802,1818,1834,1850},
{1803,1819,1835,1851},
{1804,1820,1836,1852},
{1805,1821,1837,1853},
{1806,1822,1838,1854},
{1807,1823,1839,1855},
{1856,1872,1888,1904},
{1857,1873,1889,1905},
{1858,1874,1890,1906},
{1859,1875,1891,1907},
{1860,1876,1892,1908},
{1861,1877,1893,1909},
{1862,1878,1894,1910},
{1863,1879,1895,1911},
{1864,1880,1896,1912},
{1865,1881,1897,1913},
{1866,1882,1898,1914},
{1867,1883,1899,1915},
{1868,1884,1900,1916},
{1869,1885,1901,1917},
{1870,1886,1902,1918},
{1871,1887,1903,1919},
{1920,1936,1952,1968},
{1921,1937,1953,1969},
{1922,1938,1954,1970},
{1923,1939,1955,1971},
{1924,1940,1956,1972},
{1925,1941,1957,1973},
{1926,1942,1958,1974},
{1927,1943,1959,1975},
{1928,1944,1960,1976},
{1929,1945,1961,1977},
{1930,1946,1962,1978},
{1931,1947,1963,1979},
{1932,1948,1964,1980},
{1933,1949,1965,1981},
{1934,1950,1966,1982},
{1935,1951,1967,1983},
{1984,2000,2016,2032},
{1985,2001,2017,2033},
{1986,2002,2018,2034},
{1987,2003,2019,2035},
{1988,2004,2020,2036},
{1989,2005,2021,2037},
{1990,2006,2022,2038},
{1991,2007,2023,2039},
{1992,2008,2024,2040},
{1993,2009,2025,2041},
{1994,2010,2026,2042},
{1995,2011,2027,2043},
{1996,2012,2028,2044},
{1997,2013,2029,2045},
{1998,2014,2030,2046},
{1999,2015,2031,2047},
{2048,2064,2080,2096},
{2049,2065,2081,2097},
{2050,2066,2082,2098},
{2051,2067,2083,2099},
{2052,2068,2084,2100},
{2053,2069,2085,2101},
{2054,2070,2086,2102},
{2055,2071,2087,2103},
{2056,2072,2088,2104},
{2057,2073,2089,2105},
{2058,2074,2090,2106},
{2059,2075,2091,2107},
{2060,2076,2092,2108},
{2061,2077,2093,2109},
{2062,2078,2094,2110},
{2063,2079,2095,2111},
{2112,2128,2144,2160},
{2113,2129,2145,2161},
{2114,2130,2146,2162},
{2115,2131,2147,2163},
{2116,2132,2148,2164},
{2117,2133,2149,2165},
{2118,2134,2150,2166},
{2119,2135,2151,2167},
{2120,2136,2152,2168},
{2121,2137,2153,2169},
{2122,2138,2154,2170},
{2123,2139,2155,2171},
{2124,2140,2156,2172},
{2125,2141,2157,2173},
{2126,2142,2158,2174},
{2127,2143,2159,2175},
{2176,2192,2208,2224},
{2177,2193,2209,2225},
{2178,2194,2210,2226},
{2179,2195,2211,2227},
{2180,2196,2212,2228},
{2181,2197,2213,2229},
{2182,2198,2214,2230},
{2183,2199,2215,2231},
{2184,2200,2216,2232},
{2185,2201,2217,2233},
{2186,2202,2218,2234},
{2187,2203,2219,2235},
{2188,2204,2220,2236},
{2189,2205,2221,2237},
{2190,2206,2222,2238},
{2191,2207,2223,2239},
{2240,2256,2272,2288},
{2241,2257,2273,2289},
{2242,2258,2274,2290},
{2243,2259,2275,2291},
{2244,2260,2276,2292},
{2245,2261,2277,2293},
{2246,2262,2278,2294},
{2247,2263,2279,2295},
{2248,2264,2280,2296},
{2249,2265,2281,2297},
{2250,2266,2282,2298},
{2251,2267,2283,2299},
{2252,2268,2284,2300},
{2253,2269,2285,2301},
{2254,2270,2286,2302},
{2255,2271,2287,2303},
{2304,2320,2336,2352},
{2305,2321,2337,2353},
{2306,2322,2338,2354},
{2307,2323,2339,2355},
{2308,2324,2340,2356},
{2309,2325,2341,2357},
{2310,2326,2342,2358},
{2311,2327,2343,2359},
{2312,2328,2344,2360},
{2313,2329,2345,2361},
{2314,2330,2346,2362},
{2315,2331,2347,2363},
{2316,2332,2348,2364},
{2317,2333,2349,2365},
{2318,2334,2350,2366},
{2319,2335,2351,2367},
{2368,2384,2400,2416},
{2369,2385,2401,2417},
{2370,2386,2402,2418},
{2371,2387,2403,2419},
{2372,2388,2404,2420},
{2373,2389,2405,2421},
{2374,2390,2406,2422},
{2375,2391,2407,2423},
{2376,2392,2408,2424},
{2377,2393,2409,2425},
{2378,2394,2410,2426},
{2379,2395,2411,2427},
{2380,2396,2412,2428},
{2381,2397,2413,2429},
{2382,2398,2414,2430},
{2383,2399,2415,2431},
{2432,2448,2464,2480},
{2433,2449,2465,2481},
{2434,2450,2466,2482},
{2435,2451,2467,2483},
{2436,2452,2468,2484},
{2437,2453,2469,2485},
{2438,2454,2470,2486},
{2439,2455,2471,2487},
{2440,2456,2472,2488},
{2441,2457,2473,2489},
{2442,2458,2474,2490},
{2443,2459,2475,2491},
{2444,2460,2476,2492},
{2445,2461,2477,2493},
{2446,2462,2478,2494},
{2447,2463,2479,2495},
{2496,2512,2528,2544},
{2497,2513,2529,2545},
{2498,2514,2530,2546},
{2499,2515,2531,2547},
{2500,2516,2532,2548},
{2501,2517,2533,2549},
{2502,2518,2534,2550},
{2503,2519,2535,2551},
{2504,2520,2536,2552},
{2505,2521,2537,2553},
{2506,2522,2538,2554},
{2507,2523,2539,2555},
{2508,2524,2540,2556},
{2509,2525,2541,2557},
{2510,2526,2542,2558},
{2511,2527,2543,2559},
{2560,2576,2592,2608},
{2561,2577,2593,2609},
{2562,2578,2594,2610},
{2563,2579,2595,2611},
{2564,2580,2596,2612},
{2565,2581,2597,2613},
{2566,2582,2598,2614},
{2567,2583,2599,2615},
{2568,2584,2600,2616},
{2569,2585,2601,2617},
{2570,2586,2602,2618},
{2571,2587,2603,2619},
{2572,2588,2604,2620},
{2573,2589,2605,2621},
{2574,2590,2606,2622},
{2575,2591,2607,2623},
{2624,2640,2656,2672},
{2625,2641,2657,2673},
{2626,2642,2658,2674},
{2627,2643,2659,2675},
{2628,2644,2660,2676},
{2629,2645,2661,2677},
{2630,2646,2662,2678},
{2631,2647,2663,2679},
{2632,2648,2664,2680},
{2633,2649,2665,2681},
{2634,2650,2666,2682},
{2635,2651,2667,2683},
{2636,2652,2668,2684},
{2637,2653,2669,2685},
{2638,2654,2670,2686},
{2639,2655,2671,2687},
{2688,2704,2720,2736},
{2689,2705,2721,2737},
{2690,2706,2722,2738},
{2691,2707,2723,2739},
{2692,2708,2724,2740},
{2693,2709,2725,2741},
{2694,2710,2726,2742},
{2695,2711,2727,2743},
{2696,2712,2728,2744},
{2697,2713,2729,2745},
{2698,2714,2730,2746},
{2699,2715,2731,2747},
{2700,2716,2732,2748},
{2701,2717,2733,2749},
{2702,2718,2734,2750},
{2703,2719,2735,2751},
{2752,2768,2784,2800},
{2753,2769,2785,2801},
{2754,2770,2786,2802},
{2755,2771,2787,2803},
{2756,2772,2788,2804},
{2757,2773,2789,2805},
{2758,2774,2790,2806},
{2759,2775,2791,2807},
{2760,2776,2792,2808},
{2761,2777,2793,2809},
{2762,2778,2794,2810},
{2763,2779,2795,2811},
{2764,2780,2796,2812},
{2765,2781,2797,2813},
{2766,2782,2798,2814},
{2767,2783,2799,2815},
{2816,2832,2848,2864},
{2817,2833,2849,2865},
{2818,2834,2850,2866},
{2819,2835,2851,2867},
{2820,2836,2852,2868},
{2821,2837,2853,2869},
{2822,2838,2854,2870},
{2823,2839,2855,2871},
{2824,2840,2856,2872},
{2825,2841,2857,2873},
{2826,2842,2858,2874},
{2827,2843,2859,2875},
{2828,2844,2860,2876},
{2829,2845,2861,2877},
{2830,2846,2862,2878},
{2831,2847,2863,2879},
{2880,2896,2912,2928},
{2881,2897,2913,2929},
{2882,2898,2914,2930},
{2883,2899,2915,2931},
{2884,2900,2916,2932},
{2885,2901,2917,2933},
{2886,2902,2918,2934},
{2887,2903,2919,2935},
{2888,2904,2920,2936},
{2889,2905,2921,2937},
{2890,2906,2922,2938},
{2891,2907,2923,2939},
{2892,2908,2924,2940},
{2893,2909,2925,2941},
{2894,2910,2926,2942},
{2895,2911,2927,2943},
{2944,2960,2976,2992},
{2945,2961,2977,2993},
{2946,2962,2978,2994},
{2947,2963,2979,2995},
{2948,2964,2980,2996},
{2949,2965,2981,2997},
{2950,2966,2982,2998},
{2951,2967,2983,2999},
{2952,2968,2984,3000},
{2953,2969,2985,3001},
{2954,2970,2986,3002},
{2955,2971,2987,3003},
{2956,2972,2988,3004},
{2957,2973,2989,3005},
{2958,2974,2990,3006},
{2959,2975,2991,3007},
{3008,3024,3040,3056},
{3009,3025,3041,3057},
{3010,3026,3042,3058},
{3011,3027,3043,3059},
{3012,3028,3044,3060},
{3013,3029,3045,3061},
{3014,3030,3046,3062},
{3015,3031,3047,3063},
{3016,3032,3048,3064},
{3017,3033,3049,3065},
{3018,3034,3050,3066},
{3019,3035,3051,3067},
{3020,3036,3052,3068},
{3021,3037,3053,3069},
{3022,3038,3054,3070},
{3023,3039,3055,3071},
{3072,3088,3104,3120},
{3073,3089,3105,3121},
{3074,3090,3106,3122},
{3075,3091,3107,3123},
{3076,3092,3108,3124},
{3077,3093,3109,3125},
{3078,3094,3110,3126},
{3079,3095,3111,3127},
{3080,3096,3112,3128},
{3081,3097,3113,3129},
{3082,3098,3114,3130},
{3083,3099,3115,3131},
{3084,3100,3116,3132},
{3085,3101,3117,3133},
{3086,3102,3118,3134},
{3087,3103,3119,3135},
{3136,3152,3168,3184},
{3137,3153,3169,3185},
{3138,3154,3170,3186},
{3139,3155,3171,3187},
{3140,3156,3172,3188},
{3141,3157,3173,3189},
{3142,3158,3174,3190},
{3143,3159,3175,3191},
{3144,3160,3176,3192},
{3145,3161,3177,3193},
{3146,3162,3178,3194},
{3147,3163,3179,3195},
{3148,3164,3180,3196},
{3149,3165,3181,3197},
{3150,3166,3182,3198},
{3151,3167,3183,3199},
{3200,3216,3232,3248},
{3201,3217,3233,3249},
{3202,3218,3234,3250},
{3203,3219,3235,3251},
{3204,3220,3236,3252},
{3205,3221,3237,3253},
{3206,3222,3238,3254},
{3207,3223,3239,3255},
{3208,3224,3240,3256},
{3209,3225,3241,3257},
{3210,3226,3242,3258},
{3211,3227,3243,3259},
{3212,3228,3244,3260},
{3213,3229,3245,3261},
{3214,3230,3246,3262},
{3215,3231,3247,3263},
{3264,3280,3296,3312},
{3265,3281,3297,3313},
{3266,3282,3298,3314},
{3267,3283,3299,3315},
{3268,3284,3300,3316},
{3269,3285,3301,3317},
{3270,3286,3302,3318},
{3271,3287,3303,3319},
{3272,3288,3304,3320},
{3273,3289,3305,3321},
{3274,3290,3306,3322},
{3275,3291,3307,3323},
{3276,3292,3308,3324},
{3277,3293,3309,3325},
{3278,3294,3310,3326},
{3279,3295,3311,3327},
{3328,3344,3360,3376},
{3329,3345,3361,3377},
{3330,3346,3362,3378},
{3331,3347,3363,3379},
{3332,3348,3364,3380},
{3333,3349,3365,3381},
{3334,3350,3366,3382},
{3335,3351,3367,3383},
{3336,3352,3368,3384},
{3337,3353,3369,3385},
{3338,3354,3370,3386},
{3339,3355,3371,3387},
{3340,3356,3372,3388},
{3341,3357,3373,3389},
{3342,3358,3374,3390},
{3343,3359,3375,3391},
{3392,3408,3424,3440},
{3393,3409,3425,3441},
{3394,3410,3426,3442},
{3395,3411,3427,3443},
{3396,3412,3428,3444},
{3397,3413,3429,3445},
{3398,3414,3430,3446},
{3399,3415,3431,3447},
{3400,3416,3432,3448},
{3401,3417,3433,3449},
{3402,3418,3434,3450},
{3403,3419,3435,3451},
{3404,3420,3436,3452},
{3405,3421,3437,3453},
{3406,3422,3438,3454},
{3407,3423,3439,3455},
{3456,3472,3488,3504},
{3457,3473,3489,3505},
{3458,3474,3490,3506},
{3459,3475,3491,3507},
{3460,3476,3492,3508},
{3461,3477,3493,3509},
{3462,3478,3494,3510},
{3463,3479,3495,3511},
{3464,3480,3496,3512},
{3465,3481,3497,3513},
{3466,3482,3498,3514},
{3467,3483,3499,3515},
{3468,3484,3500,3516},
{3469,3485,3501,3517},
{3470,3486,3502,3518},
{3471,3487,3503,3519},
{3520,3536,3552,3568},
{3521,3537,3553,3569},
{3522,3538,3554,3570},
{3523,3539,3555,3571},
{3524,3540,3556,3572},
{3525,3541,3557,3573},
{3526,3542,3558,3574},
{3527,3543,3559,3575},
{3528,3544,3560,3576},
{3529,3545,3561,3577},
{3530,3546,3562,3578},
{3531,3547,3563,3579},
{3532,3548,3564,3580},
{3533,3549,3565,3581},
{3534,3550,3566,3582},
{3535,3551,3567,3583},
{3584,3600,3616,3632},
{3585,3601,3617,3633},
{3586,3602,3618,3634},
{3587,3603,3619,3635},
{3588,3604,3620,3636},
{3589,3605,3621,3637},
{3590,3606,3622,3638},
{3591,3607,3623,3639},
{3592,3608,3624,3640},
{3593,3609,3625,3641},
{3594,3610,3626,3642},
{3595,3611,3627,3643},
{3596,3612,3628,3644},
{3597,3613,3629,3645},
{3598,3614,3630,3646},
{3599,3615,3631,3647},
{3648,3664,3680,3696},
{3649,3665,3681,3697},
{3650,3666,3682,3698},
{3651,3667,3683,3699},
{3652,3668,3684,3700},
{3653,3669,3685,3701},
{3654,3670,3686,3702},
{3655,3671,3687,3703},
{3656,3672,3688,3704},
{3657,3673,3689,3705},
{3658,3674,3690,3706},
{3659,3675,3691,3707},
{3660,3676,3692,3708},
{3661,3677,3693,3709},
{3662,3678,3694,3710},
{3663,3679,3695,3711},
{3712,3728,3744,3760},
{3713,3729,3745,3761},
{3714,3730,3746,3762},
{3715,3731,3747,3763},
{3716,3732,3748,3764},
{3717,3733,3749,3765},
{3718,3734,3750,3766},
{3719,3735,3751,3767},
{3720,3736,3752,3768},
{3721,3737,3753,3769},
{3722,3738,3754,3770},
{3723,3739,3755,3771},
{3724,3740,3756,3772},
{3725,3741,3757,3773},
{3726,3742,3758,3774},
{3727,3743,3759,3775},
{3776,3792,3808,3824},
{3777,3793,3809,3825},
{3778,3794,3810,3826},
{3779,3795,3811,3827},
{3780,3796,3812,3828},
{3781,3797,3813,3829},
{3782,3798,3814,3830},
{3783,3799,3815,3831},
{3784,3800,3816,3832},
{3785,3801,3817,3833},
{3786,3802,3818,3834},
{3787,3803,3819,3835},
{3788,3804,3820,3836},
{3789,3805,3821,3837},
{3790,3806,3822,3838},
{3791,3807,3823,3839},
{3840,3856,3872,3888},
{3841,3857,3873,3889},
{3842,3858,3874,3890},
{3843,3859,3875,3891},
{3844,3860,3876,3892},
{3845,3861,3877,3893},
{3846,3862,3878,3894},
{3847,3863,3879,3895},
{3848,3864,3880,3896},
{3849,3865,3881,3897},
{3850,3866,3882,3898},
{3851,3867,3883,3899},
{3852,3868,3884,3900},
{3853,3869,3885,3901},
{3854,3870,3886,3902},
{3855,3871,3887,3903},
{3904,3920,3936,3952},
{3905,3921,3937,3953},
{3906,3922,3938,3954},
{3907,3923,3939,3955},
{3908,3924,3940,3956},
{3909,3925,3941,3957},
{3910,3926,3942,3958},
{3911,3927,3943,3959},
{3912,3928,3944,3960},
{3913,3929,3945,3961},
{3914,3930,3946,3962},
{3915,3931,3947,3963},
{3916,3932,3948,3964},
{3917,3933,3949,3965},
{3918,3934,3950,3966},
{3919,3935,3951,3967},
{3968,3984,4000,4016},
{3969,3985,4001,4017},
{3970,3986,4002,4018},
{3971,3987,4003,4019},
{3972,3988,4004,4020},
{3973,3989,4005,4021},
{3974,3990,4006,4022},
{3975,3991,4007,4023},
{3976,3992,4008,4024},
{3977,3993,4009,4025},
{3978,3994,4010,4026},
{3979,3995,4011,4027},
{3980,3996,4012,4028},
{3981,3997,4013,4029},
{3982,3998,4014,4030},
{3983,3999,4015,4031},
{4032,4048,4064,4080},
{4033,4049,4065,4081},
{4034,4050,4066,4082},
{4035,4051,4067,4083},
{4036,4052,4068,4084},
{4037,4053,4069,4085},
{4038,4054,4070,4086},
{4039,4055,4071,4087},
{4040,4056,4072,4088},
{4041,4057,4073,4089},
{4042,4058,4074,4090},
{4043,4059,4075,4091},
{4044,4060,4076,4092},
{4045,4061,4077,4093},
{4046,4062,4078,4094},
{4047,4063,4079,4095}};

#define MAX(a, b) (((a) > (b)) ? (a) : (b))

bool g_interactive_debugger_enabled = false;

tr1_hash_map<new_addr_type, unsigned> address_random_interleaving;

/* Clock Domains */

#define CORE 0x01
#define L2 0x02
#define DRAM 0x04
#define ICNT 0x08

#define MEM_LATENCY_STAT_IMPL

#include "mem_latency_stat.h"

void power_config::reg_options(class OptionParser *opp) {
  option_parser_register(opp, "-gpuwattch_xml_file", OPT_CSTR,
                         &g_power_config_name, "GPUWattch XML file",
                         "gpuwattch.xml");

  option_parser_register(opp, "-power_simulation_enabled", OPT_BOOL,
                         &g_power_simulation_enabled,
                         "Turn on power simulator (1=On, 0=Off)", "0");

  option_parser_register(opp, "-power_per_cycle_dump", OPT_BOOL,
                         &g_power_per_cycle_dump,
                         "Dump detailed power output each cycle", "0");

  // Output Data Formats
  option_parser_register(
      opp, "-power_trace_enabled", OPT_BOOL, &g_power_trace_enabled,
      "produce a file for the power trace (1=On, 0=Off)", "0");

  option_parser_register(
      opp, "-power_trace_zlevel", OPT_INT32, &g_power_trace_zlevel,
      "Compression level of the power trace output log (0=no comp, 9=highest)",
      "6");

  option_parser_register(
      opp, "-steady_power_levels_enabled", OPT_BOOL,
      &g_steady_power_levels_enabled,
      "produce a file for the steady power levels (1=On, 0=Off)", "0");

  option_parser_register(opp, "-steady_state_definition", OPT_CSTR,
                         &gpu_steady_state_definition,
                         "allowed deviation:number of samples", "8:4");
}

void memory_config::reg_options(class OptionParser *opp) {
  option_parser_register(opp, "-gpgpu_perf_sim_memcpy", OPT_BOOL,
                         &m_perf_sim_memcpy, "Fill the L2 cache on memcpy",
                         "1");
  option_parser_register(opp, "-gpgpu_simple_dram_model", OPT_BOOL,
                         &simple_dram_model,
                         "simple_dram_model with fixed latency and BW", "0");
  option_parser_register(opp, "-gpgpu_dram_scheduler", OPT_INT32,
                         &scheduler_type, "0 = fifo, 1 = FR-FCFS (defaul)",
                         "1");
  option_parser_register(opp, "-gpgpu_dram_partition_queues", OPT_CSTR,
                         &gpgpu_L2_queue_config, "i2$:$2d:d2$:$2i", "8:8:8:8");

  option_parser_register(opp, "-l2_ideal", OPT_BOOL, &l2_ideal,
                         "Use a ideal L2 cache that always hit", "0");
  option_parser_register(opp, "-gpgpu_cache:dl2", OPT_CSTR,
                         &m_L2_config.m_config_string,
                         "unified banked L2 data cache config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq>}",
                         "64:128:8,L:B:m:N,A:16:4,4");
  option_parser_register(opp, "-gpgpu_cache:dl2_texture_only", OPT_BOOL,
                         &m_L2_texure_only, "L2 cache used for texture only",
                         "1");
  option_parser_register(
      opp, "-gpgpu_n_mem", OPT_UINT32, &m_n_mem,
      "number of memory modules (e.g. memory controllers) in gpu", "8");
  option_parser_register(opp, "-gpgpu_n_sub_partition_per_mchannel", OPT_UINT32,
                         &m_n_sub_partition_per_memory_channel,
                         "number of memory subpartition in each memory module",
                         "1");
  option_parser_register(opp, "-gpgpu_n_mem_per_ctrlr", OPT_UINT32,
                         &gpu_n_mem_per_ctrlr,
                         "number of memory chips per memory controller", "1");
  option_parser_register(opp, "-gpgpu_memlatency_stat", OPT_INT32,
                         &gpgpu_memlatency_stat,
                         "track and display latency statistics 0x2 enables MC, "
                         "0x4 enables queue logs",
                         "0");
  option_parser_register(opp, "-gpgpu_frfcfs_dram_sched_queue_size", OPT_INT32,
                         &gpgpu_frfcfs_dram_sched_queue_size,
                         "0 = unlimited (default); # entries per chip", "0");
  option_parser_register(opp, "-gpgpu_dram_return_queue_size", OPT_INT32,
                         &gpgpu_dram_return_queue_size,
                         "0 = unlimited (default); # entries per chip", "0");
  option_parser_register(opp, "-gpgpu_dram_buswidth", OPT_UINT32, &busW,
                         "default = 4 bytes (8 bytes per cycle at DDR)", "4");
  option_parser_register(
      opp, "-gpgpu_dram_burst_length", OPT_UINT32, &BL,
      "Burst length of each DRAM request (default = 4 data bus cycle)", "4");
  option_parser_register(opp, "-dram_data_command_freq_ratio", OPT_UINT32,
                         &data_command_freq_ratio,
                         "Frequency ratio between DRAM data bus and command "
                         "bus (default = 2 times, i.e. DDR)",
                         "2");
  option_parser_register(
      opp, "-gpgpu_dram_timing_opt", OPT_CSTR, &gpgpu_dram_timing_opt,
      "DRAM timing parameters = "
      "{nbk:tCCD:tRRD:tRCD:tRAS:tRP:tRC:CL:WL:tCDLR:tWR:nbkgrp:tCCDL:tRTPL}",
      "4:2:8:12:21:13:34:9:4:5:13:1:0:0");
  option_parser_register(opp, "-gpgpu_l2_rop_latency", OPT_UINT32, &rop_latency,
                         "ROP queue latency (default 85)", "85");
  option_parser_register(opp, "-dram_latency", OPT_UINT32, &dram_latency,
                         "DRAM latency (default 30)", "30");
  option_parser_register(opp, "-dram_dual_bus_interface", OPT_UINT32,
                         &dual_bus_interface,
                         "dual_bus_interface (default = 0) ", "0");
  option_parser_register(opp, "-dram_bnk_indexing_policy", OPT_UINT32,
                         &dram_bnk_indexing_policy,
                         "dram_bnk_indexing_policy (0 = normal indexing, 1 = "
                         "Xoring with the higher bits) (Default = 0)",
                         "0");
  option_parser_register(opp, "-dram_bnkgrp_indexing_policy", OPT_UINT32,
                         &dram_bnkgrp_indexing_policy,
                         "dram_bnkgrp_indexing_policy (0 = take higher bits, 1 "
                         "= take lower bits) (Default = 0)",
                         "0");
  option_parser_register(opp, "-dram_seperate_write_queue_enable", OPT_BOOL,
                         &seperate_write_queue_enabled,
                         "Seperate_Write_Queue_Enable", "0");
  option_parser_register(opp, "-dram_write_queue_size", OPT_CSTR,
                         &write_queue_size_opt, "Write_Queue_Size", "32:28:16");
  option_parser_register(
      opp, "-dram_elimnate_rw_turnaround", OPT_BOOL, &elimnate_rw_turnaround,
      "elimnate_rw_turnaround i.e set tWTR and tRTW = 0", "0");
  option_parser_register(opp, "-icnt_flit_size", OPT_UINT32, &icnt_flit_size,
                         "icnt_flit_size", "32");
  m_address_mapping.addrdec_setoption(opp);
}

void shader_core_config::reg_options(class OptionParser *opp) {
  option_parser_register(opp, "-gpgpu_simd_model", OPT_INT32, &model,
                         "1 = post-dominator", "1");
  option_parser_register(opp, "-gpgpu_simd_rec_time_out", OPT_INT32, &rec_time_out,
                         "-1 = no reconvergence time out", "-1");
  option_parser_register(opp, "-gpgpu_simd_rec_size", OPT_INT32, &num_rec_entries,
                         "number of physical entries in the reconvergence table", "32");
  option_parser_register(opp, "-gpgpu_simd_st_size", OPT_INT32, &num_st_entries,
                         "number of physical entries in the splits table", "33");
  option_parser_register(opp, "-gpgpu_simd_rec_replacement", OPT_INT32, &rec_replacement,
                         "reconvergence table replacement policy", "0");
  option_parser_register(opp, "-gpgpu_simd_st_replacement", OPT_INT32, &st_replacement,
                         "splits table replacement policy", "0");
  option_parser_register(
      opp, "-gpgpu_shader_core_pipeline", OPT_CSTR,
      &gpgpu_shader_core_pipeline_opt,
      "shader core pipeline config, i.e., {<nthread>:<warpsize>}", "1024:32");
  option_parser_register(opp, "-gpgpu_tex_cache:l1", OPT_CSTR,
                         &m_L1T_config.m_config_string,
                         "per-shader L1 texture cache  (READ-ONLY) config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq>:<rf>}",
                         "8:128:5,L:R:m:N,F:128:4,128:2");
  option_parser_register(
      opp, "-gpgpu_const_cache:l1", OPT_CSTR, &m_L1C_config.m_config_string,
      "per-shader L1 constant memory cache  (READ-ONLY) config "
      " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_alloc>,<mshr>:<N>:<"
      "merge>,<mq>} ",
      "64:64:2,L:R:f:N,A:2:32,4");
  option_parser_register(
      opp, "-gpgpu_rt_cache:l1", OPT_CSTR, &m_L0C_config.m_config_string,
      "per-shader L1 constant memory cache  (READ-ONLY) config "
      " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_alloc>,<mshr>:<N>:<"
      "merge>,<mq>} ",
      "64:64:2,L:R:f:N,A:2:32,4");
  option_parser_register(
      opp, "-gpgpu_rt_use_l1", OPT_BOOL, &m_rt_use_l1d,
      "use existing L1 cache instead of dedicated L0 cache ",
      "1");
  option_parser_register(
      opp, "-gpgpu_rt_perfect_mem", OPT_BOOL, &m_rt_perfect_mem,
      "assume 0 latency BVH accesses ",
      "0");
  option_parser_register(
      opp, "-gpgpu_rt_coherence_engine", OPT_BOOL, &m_rt_coherence_engine,
      "enable coherency engine (ray sorting) ",
      "0");
  option_parser_register(
      opp, "-gpgpu_rt_coherence_engine_config", OPT_CSTR, &m_rt_coherence_engine_config_str,
      "max cycles, hash ",
      "100, d");
  option_parser_register(
      opp, "-gpgpu_rt_disable_rt_cache", OPT_BOOL, &bypassL0Complet,
      "bypass RT cache and connect RT unit directly to interconnect ",
      "0");
  option_parser_register(
      opp, "-gpgpu_rt_max_warps", OPT_UINT32, &m_rt_max_warps,
      "max number of warps concurrently in one rt core ",
      "0");
  option_parser_register(
      opp, "-gpgpu_rt_max_mshr", OPT_UINT32, &m_rt_max_mshr_entries,
      "max number of MSHR entries in RT unit ",
      "32");
  option_parser_register(
      opp, "-gpgpu_rt_coalesce_warps", OPT_BOOL, &m_rt_coalesce_warps,
      "try to coalesce memory requests between warps ",
      "0");
  option_parser_register(
      opp, "-gpgpu_rt_intersection_latency", OPT_CSTR, &m_rt_intersection_latency_str,
      "latency of pipelined intersection tests (7 types)",
      "0,0,0,0,0,0,0");
  option_parser_register(
      opp, "-gpgpu_rt_intersection_table_type", OPT_UINT32, &m_rt_intersection_table_type,
      "type of intersection table",
      "0");
  option_parser_register(opp, "-gpgpu_cache:il1", OPT_CSTR,
                         &m_L1I_config.m_config_string,
                         "shader L1 instruction cache config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq>} ",
                         "4:256:4,L:R:f:N,A:2:32,4");
  option_parser_register(opp, "-gpgpu_cache:dl1", OPT_CSTR,
                         &m_L1D_config.m_config_string,
                         "per-shader L1 data cache config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq> | none}",
                         "none");
  option_parser_register(opp, "-gpgpu_l1_banks", OPT_UINT32,
                         &m_L1D_config.l1_banks, "The number of L1 cache banks",
                         "1");
  option_parser_register(opp, "-gpgpu_l1_banks_byte_interleaving", OPT_UINT32,
                         &m_L1D_config.l1_banks_byte_interleaving,
                         "l1 banks byte interleaving granularity", "32");
  option_parser_register(opp, "-gpgpu_l1_banks_hashing_function", OPT_UINT32,
                         &m_L1D_config.l1_banks_hashing_function,
                         "l1 banks hashing function", "0");
  option_parser_register(opp, "-gpgpu_l1_latency", OPT_UINT32,
                         &m_L1D_config.l1_latency, "L1 Hit Latency", "1");
  option_parser_register(opp, "-gpgpu_smem_latency", OPT_UINT32, &smem_latency,
                         "smem Latency", "3");
  option_parser_register(opp, "-gpgpu_cache:dl1PrefL1", OPT_CSTR,
                         &m_L1D_config.m_config_stringPrefL1,
                         "per-shader L1 data cache config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq> | none}",
                         "none");
  option_parser_register(opp, "-gpgpu_cache:dl1PrefShared", OPT_CSTR,
                         &m_L1D_config.m_config_stringPrefShared,
                         "per-shader L1 data cache config "
                         " {<nsets>:<bsize>:<assoc>,<rep>:<wr>:<alloc>:<wr_"
                         "alloc>,<mshr>:<N>:<merge>,<mq> | none}",
                         "none");
  option_parser_register(opp, "-gpgpu_gmem_skip_L1D", OPT_BOOL, &gmem_skip_L1D,
                         "global memory access skip L1D cache (implements "
                         "-Xptxas -dlcm=cg, default=no skip)",
                         "0");

  option_parser_register(opp, "-gpgpu_perfect_mem", OPT_BOOL,
                         &gpgpu_perfect_mem,
                         "enable perfect memory mode (no cache miss)", "0");
  option_parser_register(
      opp, "-n_regfile_gating_group", OPT_UINT32, &n_regfile_gating_group,
      "group of lanes that should be read/written together)", "4");
  option_parser_register(
      opp, "-gpgpu_clock_gated_reg_file", OPT_BOOL, &gpgpu_clock_gated_reg_file,
      "enable clock gated reg file for power calculations", "0");
  option_parser_register(
      opp, "-gpgpu_clock_gated_lanes", OPT_BOOL, &gpgpu_clock_gated_lanes,
      "enable clock gated lanes for power calculations", "0");
  option_parser_register(opp, "-gpgpu_shader_registers", OPT_UINT32,
                         &gpgpu_shader_registers,
                         "Number of registers per shader core. Limits number "
                         "of concurrent CTAs. (default 8192)",
                         "8192");
  option_parser_register(
      opp, "-gpgpu_registers_per_block", OPT_UINT32, &gpgpu_registers_per_block,
      "Maximum number of registers per CTA. (default 8192)", "8192");
  option_parser_register(opp, "-gpgpu_ignore_resources_limitation", OPT_BOOL,
                         &gpgpu_ignore_resources_limitation,
                         "gpgpu_ignore_resources_limitation (default 0)", "0");
  option_parser_register(
      opp, "-gpgpu_shader_cta", OPT_UINT32, &max_cta_per_core,
      "Maximum number of concurrent CTAs in shader (default 8)", "8");
  option_parser_register(
      opp, "-gpgpu_num_cta_barriers", OPT_UINT32, &max_barriers_per_cta,
      "Maximum number of named barriers per CTA (default 16)", "16");
  option_parser_register(opp, "-gpgpu_n_clusters", OPT_UINT32, &n_simt_clusters,
                         "number of processing clusters", "10");
  option_parser_register(opp, "-gpgpu_n_cores_per_cluster", OPT_UINT32,
                         &n_simt_cores_per_cluster,
                         "number of simd cores per cluster", "3");
  option_parser_register(opp, "-gpgpu_n_cluster_ejection_buffer_size",
                         OPT_UINT32, &n_simt_ejection_buffer_size,
                         "number of packets in ejection buffer", "8");
  option_parser_register(
      opp, "-gpgpu_n_ldst_response_buffer_size", OPT_UINT32,
      &ldst_unit_response_queue_size,
      "number of response packets in ld/st unit ejection buffer", "2");
  option_parser_register(
      opp, "-gpgpu_shmem_per_block", OPT_UINT32, &gpgpu_shmem_per_block,
      "Size of shared memory per thread block or CTA (default 48kB)", "49152");
  option_parser_register(
      opp, "-gpgpu_shmem_size", OPT_UINT32, &gpgpu_shmem_size,
      "Size of shared memory per shader core (default 16kB)", "16384");
  option_parser_register(opp, "-gpgpu_adaptive_cache_config", OPT_UINT32,
                         &adaptive_cache_config, "adaptive_cache_config", "0");
  option_parser_register(
      opp, "-gpgpu_shmem_sizeDefault", OPT_UINT32, &gpgpu_shmem_sizeDefault,
      "Size of shared memory per shader core (default 16kB)", "16384");
  option_parser_register(
      opp, "-gpgpu_shmem_size_PrefL1", OPT_UINT32, &gpgpu_shmem_sizePrefL1,
      "Size of shared memory per shader core (default 16kB)", "16384");
  option_parser_register(opp, "-gpgpu_shmem_size_PrefShared", OPT_UINT32,
                         &gpgpu_shmem_sizePrefShared,
                         "Size of shared memory per shader core (default 16kB)",
                         "16384");
  option_parser_register(
      opp, "-gpgpu_shmem_num_banks", OPT_UINT32, &num_shmem_bank,
      "Number of banks in the shared memory in each shader core (default 16)",
      "16");
  option_parser_register(
      opp, "-gpgpu_shmem_limited_broadcast", OPT_BOOL, &shmem_limited_broadcast,
      "Limit shared memory to do one broadcast per cycle (default on)", "1");
  option_parser_register(opp, "-gpgpu_shmem_warp_parts", OPT_INT32,
                         &mem_warp_parts,
                         "Number of portions a warp is divided into for shared "
                         "memory bank conflict check ",
                         "2");
  option_parser_register(
      opp, "-gpgpu_mem_unit_ports", OPT_INT32, &mem_unit_ports,
      "The number of memory transactions allowed per core cycle", "1");
  option_parser_register(opp, "-gpgpu_shmem_warp_parts", OPT_INT32,
                         &mem_warp_parts,
                         "Number of portions a warp is divided into for shared "
                         "memory bank conflict check ",
                         "2");
  option_parser_register(
      opp, "-gpgpu_warpdistro_shader", OPT_INT32, &gpgpu_warpdistro_shader,
      "Specify which shader core to collect the warp size distribution from",
      "-1");
  option_parser_register(
      opp, "-gpgpu_warp_issue_shader", OPT_INT32, &gpgpu_warp_issue_shader,
      "Specify which shader core to collect the warp issue distribution from",
      "0");
  option_parser_register(opp, "-gpgpu_local_mem_map", OPT_BOOL,
                         &gpgpu_local_mem_map,
                         "Mapping from local memory space address to simulated "
                         "GPU physical address space (default = enabled)",
                         "1");
  option_parser_register(opp, "-gpgpu_num_reg_banks", OPT_INT32,
                         &gpgpu_num_reg_banks,
                         "Number of register banks (default = 8)", "8");
  option_parser_register(
      opp, "-gpgpu_reg_bank_use_warp_id", OPT_BOOL, &gpgpu_reg_bank_use_warp_id,
      "Use warp ID in mapping registers to banks (default = off)", "0");
  option_parser_register(opp, "-gpgpu_sub_core_model", OPT_BOOL,
                         &sub_core_model,
                         "Sub Core Volta/Pascal model (default = off)", "0");
  option_parser_register(opp, "-gpgpu_enable_specialized_operand_collector",
                         OPT_BOOL, &enable_specialized_operand_collector,
                         "enable_specialized_operand_collector", "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_sp",
                         OPT_INT32, &gpgpu_operand_collector_num_units_sp,
                         "number of collector units (default = 4)", "4");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_dp",
                         OPT_INT32, &gpgpu_operand_collector_num_units_dp,
                         "number of collector units (default = 0)", "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_sfu",
                         OPT_INT32, &gpgpu_operand_collector_num_units_sfu,
                         "number of collector units (default = 4)", "4");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_int",
                         OPT_INT32, &gpgpu_operand_collector_num_units_int,
                         "number of collector units (default = 0)", "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_tensor_core",
                         OPT_INT32,
                         &gpgpu_operand_collector_num_units_tensor_core,
                         "number of collector units (default = 4)", "4");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_mem",
                         OPT_INT32, &gpgpu_operand_collector_num_units_mem,
                         "number of collector units (default = 2)", "2");
  option_parser_register(opp, "-gpgpu_operand_collector_num_units_gen",
                         OPT_INT32, &gpgpu_operand_collector_num_units_gen,
                         "number of collector units (default = 0)", "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_sp",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_sp,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_dp",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_dp,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_sfu",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_sfu,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_int",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_int,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(
      opp, "-gpgpu_operand_collector_num_in_ports_tensor_core", OPT_INT32,
      &gpgpu_operand_collector_num_in_ports_tensor_core,
      "number of collector unit in ports (default = 1)", "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_mem",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_mem,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_in_ports_gen",
                         OPT_INT32, &gpgpu_operand_collector_num_in_ports_gen,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_sp",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_sp,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_dp",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_dp,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_sfu",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_sfu,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_int",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_int,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(
      opp, "-gpgpu_operand_collector_num_out_ports_tensor_core", OPT_INT32,
      &gpgpu_operand_collector_num_out_ports_tensor_core,
      "number of collector unit in ports (default = 1)", "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_mem",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_mem,
                         "number of collector unit in ports (default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_operand_collector_num_out_ports_gen",
                         OPT_INT32, &gpgpu_operand_collector_num_out_ports_gen,
                         "number of collector unit in ports (default = 0)",
                         "0");
  option_parser_register(opp, "-gpgpu_coalesce_arch", OPT_INT32,
                         &gpgpu_coalesce_arch,
                         "Coalescing arch (GT200 = 13, Fermi = 20)", "13");
  option_parser_register(opp, "-gpgpu_num_sched_per_core", OPT_INT32,
                         &gpgpu_num_sched_per_core,
                         "Number of warp schedulers per core", "1");
  option_parser_register(opp, "-gpgpu_max_insn_issue_per_warp", OPT_INT32,
                         &gpgpu_max_insn_issue_per_warp,
                         "Max number of instructions that can be issued per "
                         "warp in one cycle by scheduler (either 1 or 2)",
                         "2");
  option_parser_register(opp, "-gpgpu_dual_issue_diff_exec_units", OPT_BOOL,
                         &gpgpu_dual_issue_diff_exec_units,
                         "should dual issue use two different execution unit "
                         "resources (Default = 1)",
                         "1");
  option_parser_register(opp, "-gpgpu_simt_core_sim_order", OPT_INT32,
                         &simt_core_sim_order,
                         "Select the simulation order of cores in a cluster "
                         "(0=Fix, 1=Round-Robin)",
                         "1");
  option_parser_register(
      opp, "-gpgpu_pipeline_widths", OPT_CSTR, &pipeline_widths_string,
      "Pipeline widths "
      "ID_OC_SP,ID_OC_DP,ID_OC_INT,ID_OC_SFU,ID_OC_MEM,OC_EX_SP,OC_EX_DP,OC_EX_"
      "INT,OC_EX_SFU,OC_EX_MEM,EX_WB,ID_OC_TENSOR_CORE,OC_EX_TENSOR_CORE,ID_OC_RT,OC_EX_RT",
      "1,1,1,1,1,1,1,1,1,1,1,1,1,1,1");
  option_parser_register(opp, "-gpgpu_tensor_core_avail", OPT_INT32,
                         &gpgpu_tensor_core_avail,
                         "Tensor Core Available (default=0)", "0");
  option_parser_register(opp, "-gpgpu_num_sp_units", OPT_INT32,
                         &gpgpu_num_sp_units, "Number of SP units (default=1)",
                         "1");
  option_parser_register(opp, "-gpgpu_num_dp_units", OPT_INT32,
                         &gpgpu_num_dp_units, "Number of DP units (default=0)",
                         "0");
  option_parser_register(opp, "-gpgpu_num_int_units", OPT_INT32,
                         &gpgpu_num_int_units,
                         "Number of INT units (default=0)", "0");
  option_parser_register(opp, "-gpgpu_num_sfu_units", OPT_INT32,
                         &gpgpu_num_sfu_units, "Number of SF units (default=1)",
                         "1");
  option_parser_register(opp, "-gpgpu_num_tensor_core_units", OPT_INT32,
                         &gpgpu_num_tensor_core_units,
                         "Number of tensor_core units (default=1)", "0");
  option_parser_register(opp, "-gpgpu_num_rt_core_units", OPT_INT32,
                         &gpgpu_num_rt_core_units,
                         "Number of rt core units (default=1)", "1");
  option_parser_register(
      opp, "-gpgpu_num_mem_units", OPT_INT32, &gpgpu_num_mem_units,
      "Number if ldst units (default=1) WARNING: not hooked up to anything",
      "1");
  option_parser_register(
      opp, "-gpgpu_scheduler", OPT_CSTR, &gpgpu_scheduler_string,
      "Scheduler configuration: < lrr | gto | two_level_active > "
      "If "
      "two_level_active:<num_active_warps>:<inner_prioritization>:<outer_"
      "prioritization>"
      "For complete list of prioritization values see shader.h enum "
      "scheduler_prioritization_type"
      "Default: gto",
      "gto");

  option_parser_register(
      opp, "-gpgpu_concurrent_kernel_sm", OPT_BOOL, &gpgpu_concurrent_kernel_sm,
      "Support concurrent kernels on a SM (default = disabled)", "0");
  option_parser_register(opp, "-gpgpu_perfect_inst_const_cache", OPT_BOOL,
                         &perfect_inst_const_cache,
                         "perfect inst and const cache mode, so all inst and "
                         "const hits in the cache(default = disabled)",
                         "0");
  option_parser_register(
      opp, "-gpgpu_inst_fetch_throughput", OPT_INT32, &inst_fetch_throughput,
      "the number of fetched intruction per warp each cycle", "1");
  option_parser_register(opp, "-gpgpu_reg_file_port_throughput", OPT_INT32,
                         &reg_file_port_throughput,
                         "the number ports of the register file", "1");

  for (unsigned j = 0; j < SPECIALIZED_UNIT_NUM; ++j) {
    std::stringstream ss;
    ss << "-specialized_unit_" << j + 1;
    option_parser_register(opp, ss.str().c_str(), OPT_CSTR,
                           &specialized_unit_string[j],
                           "specialized unit config"
                           " {<enabled>,<num_units>:<latency>:<initiation>,<ID_"
                           "OC_SPEC>:<OC_EX_SPEC>,<NAME>}",
                           "0,4,4,4,4,BRA");
  }
}

void gpgpu_sim_config::reg_options(option_parser_t opp) {
  gpgpu_functional_sim_config::reg_options(opp);
  m_shader_config.reg_options(opp);
  m_memory_config.reg_options(opp);
  power_config::reg_options(opp);
  option_parser_register(opp, "-gpgpu_intermittent_stats", OPT_BOOL, &gpu_intermittent_stats,
                         "print intermittent stats", "0");
  option_parser_register(opp, "-gpgpu_intermittent_stats_freq", OPT_INT64, &gpu_intermittent_stats_freq,
                         "intermittent stats frequency", "10000");
  option_parser_register(opp, "-gpgpu_max_cycle", OPT_INT64, &gpu_max_cycle_opt,
                         "terminates gpu simulation early (0 = no limit)", "0");
  option_parser_register(opp, "-gpgpu_max_insn", OPT_INT64, &gpu_max_insn_opt,
                         "terminates gpu simulation early (0 = no limit)", "0");
  option_parser_register(opp, "-gpgpu_max_cta", OPT_INT32, &gpu_max_cta_opt,
                         "terminates gpu simulation early (0 = no limit)", "0");
  option_parser_register(opp, "-gpgpu_max_completed_cta", OPT_INT32,
                         &gpu_max_completed_cta_opt,
                         "terminates gpu simulation early (0 = no limit)", "0");
  option_parser_register(
      opp, "-gpgpu_runtime_stat", OPT_CSTR, &gpgpu_runtime_stat,
      "display runtime statistics such as dram utilization {<freq>:<flag>}",
      "10000:0");
  option_parser_register(opp, "-liveness_message_freq", OPT_INT64,
                         &liveness_message_freq,
                         "Minimum number of seconds between simulation "
                         "liveness messages (0 = always print)",
                         "1");
  option_parser_register(opp, "-gpgpu_compute_capability_major", OPT_UINT32,
                         &gpgpu_compute_capability_major,
                         "Major compute capability version number", "7");
  option_parser_register(opp, "-gpgpu_compute_capability_minor", OPT_UINT32,
                         &gpgpu_compute_capability_minor,
                         "Minor compute capability version number", "0");
  option_parser_register(opp, "-gpgpu_flush_l1_cache", OPT_BOOL,
                         &gpgpu_flush_l1_cache,
                         "Flush L1 cache at the end of each kernel call", "0");
  option_parser_register(opp, "-gpgpu_flush_l2_cache", OPT_BOOL,
                         &gpgpu_flush_l2_cache,
                         "Flush L2 cache at the end of each kernel call", "0");
  option_parser_register(
      opp, "-gpgpu_deadlock_detect", OPT_BOOL, &gpu_deadlock_detect,
      "Stop the simulation at deadlock (1=on (default), 0=off)", "1");
  option_parser_register(
      opp, "-gpgpu_ptx_instruction_classification", OPT_INT32,
      &(gpgpu_ctx->func_sim->gpgpu_ptx_instruction_classification),
      "if enabled will classify ptx instruction types per kernel (Max 255 "
      "kernels now)",
      "0");
  option_parser_register(
      opp, "-gpgpu_ptx_sim_mode", OPT_INT32,
      &(gpgpu_ctx->func_sim->g_ptx_sim_mode),
      "Select between Performance (default) or Functional simulation (1)", "0");
  option_parser_register(opp, "-gpgpu_clock_domains", OPT_CSTR,
                         &gpgpu_clock_domains,
                         "Clock Domain Frequencies in MhZ {<Core Clock>:<ICNT "
                         "Clock>:<L2 Clock>:<DRAM Clock>}",
                         "500.0:2000.0:2000.0:2000.0");
  option_parser_register(
      opp, "-gpgpu_max_concurrent_kernel", OPT_INT32, &max_concurrent_kernel,
      "maximum kernels that can run concurrently on GPU", "8");
  option_parser_register(
      opp, "-gpgpu_cflog_interval", OPT_INT32, &gpgpu_cflog_interval,
      "Interval between each snapshot in control flow logger", "0");
  option_parser_register(opp, "-visualizer_enabled", OPT_BOOL,
                         &g_visualizer_enabled,
                         "Turn on visualizer output (1=On, 0=Off)", "1");
  option_parser_register(opp, "-visualizer_outputfile", OPT_CSTR,
                         &g_visualizer_filename,
                         "Specifies the output log file for visualizer", NULL);
  option_parser_register(
      opp, "-visualizer_zlevel", OPT_INT32, &g_visualizer_zlevel,
      "Compression level of the visualizer output log (0=no comp, 9=highest)",
      "6");
  option_parser_register(opp, "-gpgpu_stack_size_limit", OPT_INT32,
                         &stack_size_limit, "GPU thread stack size", "1024");
  option_parser_register(opp, "-gpgpu_heap_size_limit", OPT_INT32,
                         &heap_size_limit, "GPU malloc heap size ", "8388608");
  option_parser_register(opp, "-gpgpu_runtime_sync_depth_limit", OPT_INT32,
                         &runtime_sync_depth_limit,
                         "GPU device runtime synchronize depth", "2");
  option_parser_register(opp, "-gpgpu_runtime_pending_launch_count_limit",
                         OPT_INT32, &runtime_pending_launch_count_limit,
                         "GPU device runtime pending launch count", "2048");
  option_parser_register(opp, "-trace_enabled", OPT_BOOL, &Trace::enabled,
                         "Turn on traces", "0");
  option_parser_register(opp, "-trace_components", OPT_CSTR, &Trace::config_str,
                         "comma seperated list of traces to enable. "
                         "Complete list found in trace_streams.tup. "
                         "Default none",
                         "none");
  option_parser_register(
      opp, "-trace_sampling_core", OPT_INT32, &Trace::sampling_core,
      "The core which is printed using CORE_DPRINTF. Default 0", "0");
  option_parser_register(opp, "-trace_sampling_memory_partition", OPT_INT32,
                         &Trace::sampling_memory_partition,
                         "The memory partition which is printed using "
                         "MEMPART_DPRINTF. Default -1 (i.e. all)",
                         "-1");
  gpgpu_ctx->stats->ptx_file_line_stats_options(opp);

  // Jin: kernel launch latency
  option_parser_register(opp, "-gpgpu_kernel_launch_latency", OPT_INT32,
                         &(gpgpu_ctx->device_runtime->g_kernel_launch_latency),
                         "Kernel launch latency in cycles. Default: 0", "0");
  option_parser_register(opp, "-gpgpu_cdp_enabled", OPT_BOOL,
                         &(gpgpu_ctx->device_runtime->g_cdp_enabled),
                         "Turn on CDP", "0");

  option_parser_register(opp, "-gpgpu_TB_launch_latency", OPT_INT32,
                         &(gpgpu_ctx->device_runtime->g_TB_launch_latency),
                         "thread block launch latency in cycles. Default: 0",
                         "0");
  option_parser_register(opp, "-gpgpu_max_simulated_rt_kernels", OPT_INT32,
                         &(gpgpu_ctx->device_runtime->g_max_sim_rt_kernels),
                         "Max simulated kernels, used to limit how many frames we render. Default: 0",
                         "0");

  option_parser_register(opp, "-custom_cta_scheduling", OPT_BOOL,
                         &(gpgpu_ctx->device_runtime->g_custom_cta_scheduling),
                         "Enable(1) or disable(0) custom CTA scheduling for ray tracing study. Default: 0",
                         "0");
  option_parser_register(opp, "-cta_group_size", OPT_INT32,
                         &(gpgpu_ctx->device_runtime->g_cta_group_size),
                         "CTA group size for custom CTA scheduling. Default: 4",
                         "4");
  option_parser_register(opp, "-interleaved_thread_to_pixel", OPT_BOOL,
                         &(gpgpu_ctx->device_runtime->g_interleaved_thread_to_pixel),
                         "Enable(1) or disable(0) CTA scheduling for ray tracing study. Interleaved thread-to-pixel mapping in stereo. Default: 0",
                         "0");
}

/////////////////////////////////////////////////////////////////////////////

void increment_x_then_y_then_z(dim3 &i, const dim3 &bound) {
  i.x++;
  if (i.x >= bound.x) {
    i.x = 0;
    i.y++;
    if (i.y >= bound.y) {
      i.y = 0;
      if (i.z < bound.z) i.z++;
    }
  }
}

void gpgpu_sim::launch(kernel_info_t *kinfo) {
  unsigned cta_size = kinfo->threads_per_cta();
  if (cta_size > m_shader_config->n_thread_per_shader) {
    printf(
        "Execution error: Shader kernel CTA (block) size is too large for "
        "microarch config.\n");
    printf("                 CTA size (x*y*z) = %u, max supported = %u\n",
           cta_size, m_shader_config->n_thread_per_shader);
    printf(
        "                 => either change -gpgpu_shader argument in "
        "gpgpusim.config file or\n");
    printf(
        "                 modify the CUDA source to decrease the kernel block "
        "size.\n");
    abort();
  }
  unsigned n = 0;
  for (n = 0; n < m_running_kernels.size(); n++) {
    if ((NULL == m_running_kernels[n]) || m_running_kernels[n]->done()) {
      m_running_kernels[n] = kinfo;
      break;
    }
  }
  assert(n < m_running_kernels.size());
}

bool gpgpu_sim::can_start_kernel() {
  for (unsigned n = 0; n < m_running_kernels.size(); n++) {
    if ((NULL == m_running_kernels[n]) || m_running_kernels[n]->done())
      return true;
  }
  return false;
}

bool gpgpu_sim::hit_max_cta_count() const {
  if (m_config.gpu_max_cta_opt != 0) {
    if ((gpu_tot_issued_cta + m_total_cta_launched) >= m_config.gpu_max_cta_opt)
      return true;
  }
  return false;
}

bool gpgpu_sim::kernel_more_cta_left(kernel_info_t *kernel) const {
  if (hit_max_cta_count()) return false;

  if (kernel && !kernel->no_more_ctas_to_run()) return true;

  return false;
}

bool gpgpu_sim::get_more_cta_left() const {
  if (hit_max_cta_count()) return false;

  for (unsigned n = 0; n < m_running_kernels.size(); n++) {
    if (m_running_kernels[n] && !m_running_kernels[n]->no_more_ctas_to_run())
      return true;
  }
  return false;
}

void gpgpu_sim::decrement_kernel_latency() {
  for (unsigned n = 0; n < m_running_kernels.size(); n++) {
    if (m_running_kernels[n] && m_running_kernels[n]->m_kernel_TB_latency)
      m_running_kernels[n]->m_kernel_TB_latency--;
  }
}

kernel_info_t *gpgpu_sim::select_kernel() {
  if (m_running_kernels[m_last_issued_kernel] &&
      !m_running_kernels[m_last_issued_kernel]->no_more_ctas_to_run() &&
      !m_running_kernels[m_last_issued_kernel]->m_kernel_TB_latency) {
    unsigned launch_uid = m_running_kernels[m_last_issued_kernel]->get_uid();
    if (std::find(m_executed_kernel_uids.begin(), m_executed_kernel_uids.end(),
                  launch_uid) == m_executed_kernel_uids.end()) {
      m_running_kernels[m_last_issued_kernel]->start_cycle =
          gpu_sim_cycle + gpu_tot_sim_cycle;
      m_executed_kernel_uids.push_back(launch_uid);
      m_executed_kernel_names.push_back(
          m_running_kernels[m_last_issued_kernel]->name());
    }
    return m_running_kernels[m_last_issued_kernel];
  }

  for (unsigned n = 0; n < m_running_kernels.size(); n++) {
    unsigned idx =
        (n + m_last_issued_kernel + 1) % m_config.max_concurrent_kernel;
    if (kernel_more_cta_left(m_running_kernels[idx]) &&
        !m_running_kernels[idx]->m_kernel_TB_latency) {
      m_last_issued_kernel = idx;
      m_running_kernels[idx]->start_cycle = gpu_sim_cycle + gpu_tot_sim_cycle;
      // record this kernel for stat print if it is the first time this kernel
      // is selected for execution
      unsigned launch_uid = m_running_kernels[idx]->get_uid();
      assert(std::find(m_executed_kernel_uids.begin(),
                       m_executed_kernel_uids.end(),
                       launch_uid) == m_executed_kernel_uids.end());
      m_executed_kernel_uids.push_back(launch_uid);
      m_executed_kernel_names.push_back(m_running_kernels[idx]->name());

      return m_running_kernels[idx];
    }
  }
  return NULL;
}

unsigned gpgpu_sim::finished_kernel() {
  if (m_finished_kernel.empty()) return 0;
  unsigned result = m_finished_kernel.front();
  m_finished_kernel.pop_front();
  return result;
}

void gpgpu_sim::set_kernel_done(kernel_info_t *kernel) {
  unsigned uid = kernel->get_uid();
  m_finished_kernel.push_back(uid);
  std::vector<kernel_info_t *>::iterator k;
  for (k = m_running_kernels.begin(); k != m_running_kernels.end(); k++) {
    if (*k == kernel) {
      kernel->end_cycle = gpu_sim_cycle + gpu_tot_sim_cycle;
      *k = NULL;
      break;
    }
  }
  assert(k != m_running_kernels.end());
}

void gpgpu_sim::stop_all_running_kernels() {
  std::vector<kernel_info_t *>::iterator k;
  for (k = m_running_kernels.begin(); k != m_running_kernels.end(); ++k) {
    if (*k != NULL) {       // If a kernel is active
      set_kernel_done(*k);  // Stop the kernel
      assert(*k == NULL);
    }
  }
}

void exec_gpgpu_sim::createSIMTCluster() {
  next_cta_group_idx = m_shader_config->n_simt_clusters;
  for (int i = 0; i < m_shader_config->n_simt_clusters; i++)
    cta_group_idx.push_back(i);
  static_cta_schedule = gpgpu_ctx->device_runtime->g_interleaved_thread_to_pixel == true ? cta_groups4_interleaved1 : cta_groups4_4096;

  m_cluster = new simt_core_cluster *[m_shader_config->n_simt_clusters];
  for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++)
    m_cluster[i] =
        new exec_simt_core_cluster(this, i, m_shader_config, m_memory_config,
                                   m_shader_stats, m_memory_stats);
}

gpgpu_sim::gpgpu_sim(const gpgpu_sim_config &config, gpgpu_context *ctx)
    : gpgpu_t(config, ctx), m_config(config) {
  gpgpu_ctx = ctx;
  m_shader_config = &m_config.m_shader_config;
  m_memory_config = &m_config.m_memory_config;
  ctx->ptx_parser->set_ptx_warp_size(m_shader_config);
  ptx_file_line_stats_create_exposed_latency_tracker(m_config.num_shader());

#ifdef GPGPUSIM_POWER_MODEL
  m_gpgpusim_wrapper = new gpgpu_sim_wrapper(config.g_power_simulation_enabled,
                                             config.g_power_config_name);
#endif

  m_shader_stats = new shader_core_stats(m_shader_config);
  m_memory_stats = new memory_stats_t(m_config.num_shader(), m_shader_config,
                                      m_memory_config, this);
  average_pipeline_duty_cycle = (float *)malloc(sizeof(float));
  active_sms = (float *)malloc(sizeof(float));
  m_power_stats =
      new power_stat_t(m_shader_config, average_pipeline_duty_cycle, active_sms,
                       m_shader_stats, m_memory_config, m_memory_stats);

  gpu_sim_insn = 0;
  gpu_tot_sim_insn = 0;
  gpu_tot_issued_cta = 0;
  gpu_completed_cta = 0;
  m_total_cta_launched = 0;
  gpu_deadlock = false;

  gpu_stall_dramfull = 0;
  gpu_stall_icnt2sh = 0;
  partiton_reqs_in_parallel = 0;
  partiton_reqs_in_parallel_total = 0;
  partiton_reqs_in_parallel_util = 0;
  partiton_reqs_in_parallel_util_total = 0;
  gpu_sim_cycle_parition_util = 0;
  gpu_tot_sim_cycle_parition_util = 0;
  partiton_replys_in_parallel = 0;
  partiton_replys_in_parallel_total = 0;

  m_memory_partition_unit =
      new memory_partition_unit *[m_memory_config->m_n_mem];
  m_memory_sub_partition =
      new memory_sub_partition *[m_memory_config->m_n_mem_sub_partition];
  for (unsigned i = 0; i < m_memory_config->m_n_mem; i++) {
    m_memory_partition_unit[i] =
        new memory_partition_unit(i, m_memory_config, m_memory_stats, this);
    for (unsigned p = 0;
         p < m_memory_config->m_n_sub_partition_per_memory_channel; p++) {
      unsigned submpid =
          i * m_memory_config->m_n_sub_partition_per_memory_channel + p;
      m_memory_sub_partition[submpid] =
          m_memory_partition_unit[i]->get_sub_partition(p);
    }
  }

  icnt_wrapper_init();
  icnt_create(m_shader_config->n_simt_clusters,
              m_memory_config->m_n_mem_sub_partition);

  time_vector_create(NUM_MEM_REQ_STAT);
  fprintf(stdout,
          "GPGPU-Sim uArch: performance model initialization complete.\n");

  m_running_kernels.resize(config.max_concurrent_kernel, NULL);
  m_last_issued_kernel = 0;
  m_last_cluster_issue = m_shader_config->n_simt_clusters -
                         1;  // this causes first launch to use simt cluster 0
  *average_pipeline_duty_cycle = 0;
  *active_sms = 0;

  last_liveness_message_time = 0;

  // Jin: functional simulation for CDP
  m_functional_sim = false;
  m_functional_sim_kernel = NULL;
}

int gpgpu_sim::shared_mem_size() const {
  return m_shader_config->gpgpu_shmem_size;
}

bool gpgpu_sim::print_intermittent_stats(unsigned long long cycle) const {
  if (m_config.gpu_intermittent_stats) {
    return cycle % m_config.gpu_intermittent_stats_freq == 0;
  }
  else {
    return false;
  }
}

int gpgpu_sim::shared_mem_per_block() const {
  return m_shader_config->gpgpu_shmem_per_block;
}

int gpgpu_sim::num_registers_per_core() const {
  return m_shader_config->gpgpu_shader_registers;
}

int gpgpu_sim::num_registers_per_block() const {
  return m_shader_config->gpgpu_registers_per_block;
}

int gpgpu_sim::wrp_size() const { return m_shader_config->warp_size; }

int gpgpu_sim::shader_clock() const { return m_config.core_freq / 1000; }

int gpgpu_sim::max_cta_per_core() const {
  return m_shader_config->max_cta_per_core;
}

int gpgpu_sim::get_max_cta(const kernel_info_t &k) const {
  return m_shader_config->max_cta(k);
}

void gpgpu_sim::set_prop(cudaDeviceProp *prop) { m_cuda_properties = prop; }

int gpgpu_sim::compute_capability_major() const {
  return m_config.gpgpu_compute_capability_major;
}

int gpgpu_sim::compute_capability_minor() const {
  return m_config.gpgpu_compute_capability_minor;
}

const struct cudaDeviceProp *gpgpu_sim::get_prop() const {
  return m_cuda_properties;
}

enum divergence_support_t gpgpu_sim::simd_model() const {
  return m_shader_config->model;
}

void gpgpu_sim_config::init_clock_domains(void) {
  sscanf(gpgpu_clock_domains, "%lf:%lf:%lf:%lf", &core_freq, &icnt_freq,
         &l2_freq, &dram_freq);
  core_freq = core_freq MhZ;
  icnt_freq = icnt_freq MhZ;
  l2_freq = l2_freq MhZ;
  dram_freq = dram_freq MhZ;
  core_period = 1 / core_freq;
  icnt_period = 1 / icnt_freq;
  dram_period = 1 / dram_freq;
  l2_period = 1 / l2_freq;
  printf("GPGPU-Sim uArch: clock freqs: %lf:%lf:%lf:%lf\n", core_freq,
         icnt_freq, l2_freq, dram_freq);
  printf("GPGPU-Sim uArch: clock periods: %.20lf:%.20lf:%.20lf:%.20lf\n",
         core_period, icnt_period, l2_period, dram_period);
}

void gpgpu_sim::reinit_clock_domains(void) {
  core_time = 0;
  dram_time = 0;
  icnt_time = 0;
  l2_time = 0;
}

bool gpgpu_sim::active() {
  if (m_config.gpu_max_cycle_opt &&
      (gpu_tot_sim_cycle + gpu_sim_cycle) >= m_config.gpu_max_cycle_opt)
    return false;
  if (m_config.gpu_max_insn_opt &&
      (gpu_tot_sim_insn + gpu_sim_insn) >= m_config.gpu_max_insn_opt)
    return false;
  if (m_config.gpu_max_cta_opt &&
      (gpu_tot_issued_cta >= m_config.gpu_max_cta_opt))
    return false;
  if (m_config.gpu_max_completed_cta_opt &&
      (gpu_completed_cta >= m_config.gpu_max_completed_cta_opt))
    return false;
  if (m_config.gpu_deadlock_detect && gpu_deadlock) return false;
  for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++)
    if (m_cluster[i]->get_not_completed() > 0) return true;
  ;
  for (unsigned i = 0; i < m_memory_config->m_n_mem; i++)
    if (m_memory_partition_unit[i]->busy() > 0) return true;
  ;
  if (icnt_busy()) return true;
  if (get_more_cta_left()) return true;
  return false;
}

void gpgpu_sim::init() {
  // run a CUDA grid on the GPU microarchitecture simulator
  gpu_sim_cycle = 0;
  gpu_sim_insn = 0;

  max_st_entries = 0;
  max_rec_entries = 0;
  max_recvg_time = 0;
  triggered_timeouts = 0;
  gpu_st_spills = 0;
  gpu_st_fills = 0;
  gpu_rt_spills = 0;
  gpu_rt_fills = 0;
  gpu_st_fills_hits = 0;
  gpu_st_fills_misses = 0;
  gpu_rt_fills_hits = 0;
  gpu_rt_fills_misses = 0;

  last_gpu_sim_insn = 0;
  m_total_cta_launched = 0;
  gpu_completed_cta = 0;
  partiton_reqs_in_parallel = 0;
  partiton_replys_in_parallel = 0;
  partiton_reqs_in_parallel_util = 0;
  gpu_sim_cycle_parition_util = 0;

  reinit_clock_domains();
  gpgpu_ctx->func_sim->set_param_gpgpu_num_shaders(m_config.num_shader());
  for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++)
    m_cluster[i]->reinit();
  m_shader_stats->new_grid();
  // initialize the control-flow, memory access, memory latency logger
  if (m_config.g_visualizer_enabled) {
    create_thread_CFlogger(gpgpu_ctx, m_config.num_shader(),
                           m_shader_config->n_thread_per_shader, 0,
                           m_config.gpgpu_cflog_interval);
  }
  shader_CTA_count_create(m_config.num_shader(), m_config.gpgpu_cflog_interval);
  if (m_config.gpgpu_cflog_interval != 0) {
    insn_warp_occ_create(m_config.num_shader(), m_shader_config->warp_size);
    shader_warp_occ_create(m_config.num_shader(), m_shader_config->warp_size,
                           m_config.gpgpu_cflog_interval);
    shader_mem_acc_create(m_config.num_shader(), m_memory_config->m_n_mem, 4,
                          m_config.gpgpu_cflog_interval);
    shader_mem_lat_create(m_config.num_shader(), m_config.gpgpu_cflog_interval);
    shader_cache_access_create(m_config.num_shader(), 3,
                               m_config.gpgpu_cflog_interval);
    set_spill_interval(m_config.gpgpu_cflog_interval * 40);
  }

  if (g_network_mode) icnt_init();

    // McPAT initialization function. Called on first launch of GPU
#ifdef GPGPUSIM_POWER_MODEL
  if (m_config.g_power_simulation_enabled) {
    init_mcpat(m_config, m_gpgpusim_wrapper, m_config.gpu_stat_sample_freq,
               gpu_tot_sim_insn, gpu_sim_insn);
  }
#endif
}

void gpgpu_sim::update_stats() {
  m_memory_stats->memlatstat_lat_pw();
  gpu_tot_sim_cycle += gpu_sim_cycle;
  gpu_tot_sim_insn += gpu_sim_insn;
  gpu_tot_issued_cta += m_total_cta_launched;
  partiton_reqs_in_parallel_total += partiton_reqs_in_parallel;
  partiton_replys_in_parallel_total += partiton_replys_in_parallel;
  partiton_reqs_in_parallel_util_total += partiton_reqs_in_parallel_util;
  gpu_tot_sim_cycle_parition_util += gpu_sim_cycle_parition_util;
  gpu_tot_occupancy += gpu_occupancy;

  gpu_sim_cycle = 0;
  partiton_reqs_in_parallel = 0;
  partiton_replys_in_parallel = 0;
  partiton_reqs_in_parallel_util = 0;
  gpu_sim_cycle_parition_util = 0;
  gpu_sim_insn = 0;
  m_total_cta_launched = 0;
  gpu_completed_cta = 0;
  gpu_occupancy = occupancy_stats();
}

void gpgpu_sim::print_stats() {
  gpgpu_ctx->stats->ptx_file_line_stats_write_file();
  gpu_print_stat();
  fflush(stdout);

  if (g_network_mode) {
    fprintf(stdout,
        "----------------------------Interconnect-DETAILS----------------------"
        "----------\n");
    icnt_display_stats();
    icnt_display_overall_stats();
    fprintf(stdout,
        "----------------------------END-of-Interconnect-DETAILS---------------"
        "----------\n");
  }
  fflush(stdout);
}

void gpgpu_sim::deadlock_check() {
  if (m_config.gpu_deadlock_detect && gpu_deadlock) {
    fflush(stdout);
    printf(
        "\n\nGPGPU-Sim uArch: ERROR ** deadlock detected: last writeback core "
        "%u @ gpu_sim_cycle %u (+ gpu_tot_sim_cycle %u) (%u cycles ago)\n",
        gpu_sim_insn_last_update_sid, (unsigned)gpu_sim_insn_last_update,
        (unsigned)(gpu_tot_sim_cycle - gpu_sim_cycle),
        (unsigned)(gpu_sim_cycle - gpu_sim_insn_last_update));
    unsigned num_cores = 0;
    for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
      unsigned not_completed = m_cluster[i]->get_not_completed();
      if (not_completed) {
        if (!num_cores) {
          printf(
              "GPGPU-Sim uArch: DEADLOCK  shader cores no longer committing "
              "instructions [core(# threads)]:\n");
          printf("GPGPU-Sim uArch: DEADLOCK  ");
          dump_pipeline((0x40|0x4|0x1), 5, 0);
          m_cluster[i]->print_not_completed(stdout);
        } else if (num_cores < 8) {
          m_cluster[i]->print_not_completed(stdout);
        } else if (num_cores >= 8) {
          printf(" + others ... ");
        }
        num_cores += m_shader_config->n_simt_cores_per_cluster;
      }
    }
    printf("\n");
    for (unsigned i = 0; i < m_memory_config->m_n_mem; i++) {
      bool busy = m_memory_partition_unit[i]->busy();
      if (busy)
        printf("GPGPU-Sim uArch DEADLOCK:  memory partition %u busy\n", i);
    }
    if (icnt_busy()) {
      printf("GPGPU-Sim uArch DEADLOCK:  iterconnect contains traffic\n");
      icnt_display_state(stdout);
    }
    printf(
        "\nRe-run the simulator in gdb and use debug routines in .gdbinit to "
        "debug this\n");
    fflush(stdout);
    abort();
  }
}

/// printing the names and uids of a set of executed kernels (usually there is
/// only one)
std::string gpgpu_sim::executed_kernel_info_string() {
  std::stringstream statout;

  statout << "kernel_name = ";
  for (unsigned int k = 0; k < m_executed_kernel_names.size(); k++) {
    statout << m_executed_kernel_names[k] << " ";
  }
  statout << std::endl;
  statout << "kernel_launch_uid = ";
  for (unsigned int k = 0; k < m_executed_kernel_uids.size(); k++) {
    statout << m_executed_kernel_uids[k] << " ";
  }
  statout << std::endl;

  return statout.str();
}
void gpgpu_sim::set_cache_config(std::string kernel_name,
                                 FuncCache cacheConfig) {
  m_special_cache_config[kernel_name] = cacheConfig;
}

FuncCache gpgpu_sim::get_cache_config(std::string kernel_name) {
  for (std::map<std::string, FuncCache>::iterator iter =
           m_special_cache_config.begin();
       iter != m_special_cache_config.end(); iter++) {
    std::string kernel = iter->first;
    if (kernel_name.compare(kernel) == 0) {
      return iter->second;
    }
  }
  return (FuncCache)0;
}

bool gpgpu_sim::has_special_cache_config(std::string kernel_name) {
  for (std::map<std::string, FuncCache>::iterator iter =
           m_special_cache_config.begin();
       iter != m_special_cache_config.end(); iter++) {
    std::string kernel = iter->first;
    if (kernel_name.compare(kernel) == 0) {
      return true;
    }
  }
  return false;
}

void gpgpu_sim::set_cache_config(std::string kernel_name) {
  if (has_special_cache_config(kernel_name)) {
    change_cache_config(get_cache_config(kernel_name));
  } else {
    change_cache_config(FuncCachePreferNone);
  }
}

void gpgpu_sim::change_cache_config(FuncCache cache_config) {
  if (cache_config != m_shader_config->m_L1D_config.get_cache_status()) {
    printf("FLUSH L1 Cache at configuration change between kernels\n");
    for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
      m_cluster[i]->cache_invalidate();
    }
  }

  switch (cache_config) {
    case FuncCachePreferNone:
      m_shader_config->m_L1D_config.init(
          m_shader_config->m_L1D_config.m_config_string, FuncCachePreferNone);
      m_shader_config->gpgpu_shmem_size =
          m_shader_config->gpgpu_shmem_sizeDefault;
      break;
    case FuncCachePreferL1:
      if ((m_shader_config->m_L1D_config.m_config_stringPrefL1 == NULL) ||
          (m_shader_config->gpgpu_shmem_sizePrefL1 == (unsigned)-1)) {
        printf("WARNING: missing Preferred L1 configuration\n");
        m_shader_config->m_L1D_config.init(
            m_shader_config->m_L1D_config.m_config_string, FuncCachePreferNone);
        m_shader_config->gpgpu_shmem_size =
            m_shader_config->gpgpu_shmem_sizeDefault;

      } else {
        m_shader_config->m_L1D_config.init(
            m_shader_config->m_L1D_config.m_config_stringPrefL1,
            FuncCachePreferL1);
        m_shader_config->gpgpu_shmem_size =
            m_shader_config->gpgpu_shmem_sizePrefL1;
      }
      break;
    case FuncCachePreferShared:
      if ((m_shader_config->m_L1D_config.m_config_stringPrefShared == NULL) ||
          (m_shader_config->gpgpu_shmem_sizePrefShared == (unsigned)-1)) {
        printf("WARNING: missing Preferred L1 configuration\n");
        m_shader_config->m_L1D_config.init(
            m_shader_config->m_L1D_config.m_config_string, FuncCachePreferNone);
        m_shader_config->gpgpu_shmem_size =
            m_shader_config->gpgpu_shmem_sizeDefault;
      } else {
        m_shader_config->m_L1D_config.init(
            m_shader_config->m_L1D_config.m_config_stringPrefShared,
            FuncCachePreferShared);
        m_shader_config->gpgpu_shmem_size =
            m_shader_config->gpgpu_shmem_sizePrefShared;
      }
      break;
    default:
      break;
  }
}

void gpgpu_sim::clear_executed_kernel_info() {
  m_executed_kernel_names.clear();
  m_executed_kernel_uids.clear();
}
void gpgpu_sim::gpu_print_stat() {
  FILE *statfout = stdout;

  std::string kernel_info_str = executed_kernel_info_string();
  fprintf(statfout, "%s", kernel_info_str.c_str());

  fprintf(statfout, "gpu_sim_cycle = %lld\n", gpu_sim_cycle);
  fprintf(statfout, "gpu_sim_insn = %lld\n", gpu_sim_insn);
  fprintf(statfout, "gpu_ipc = %12.4f\n", (float)gpu_sim_insn / gpu_sim_cycle);
  fprintf(statfout, "gpu_tot_sim_cycle = %lld\n", gpu_tot_sim_cycle + gpu_sim_cycle);
  fprintf(statfout, "gpu_tot_sim_insn = %lld\n", gpu_tot_sim_insn + gpu_sim_insn);
  fprintf(statfout, "gpu_tot_ipc = %12.4f\n", (float)(gpu_tot_sim_insn + gpu_sim_insn) /
                                       (gpu_tot_sim_cycle + gpu_sim_cycle));
  fprintf(statfout, "gpu_tot_issued_cta = %lld\n",
         gpu_tot_issued_cta + m_total_cta_launched);
  fprintf(statfout, "gpu_occupancy = %.4f%% \n", gpu_occupancy.get_occ_fraction() * 100);
  fprintf(statfout, "gpu_tot_occupancy = %.4f%% \n",
         (gpu_occupancy + gpu_tot_occupancy).get_occ_fraction() * 100);

  fprintf(statfout, "max_total_param_size = %llu\n",
          gpgpu_ctx->device_runtime->g_max_total_param_size);


  // AWARE Stats
  fprintf(statfout, "splits_table_push_back = %d\n", splits_table_push_back);
  fprintf(statfout, "splits_table_update_active_entry = %d\n", splits_table_update_active_entry);
  fprintf(statfout, "max_recvg_time = %lld\n", max_recvg_time);
  fprintf(statfout, "max_st entries = %lld\n", max_st_entries);
  fprintf(statfout, "max_rec entries = %lld\n", max_rec_entries);
  fprintf(statfout, "triggered_timeouts = %lld\n", triggered_timeouts);
  fprintf(statfout, "gpu_st_spills = %lld\n", gpu_st_spills);
  fprintf(statfout, "gpu_rt_spills = %lld\n", gpu_rt_spills);
  fprintf(statfout, "gpu_st_fills = %lld\n", gpu_st_fills);
  fprintf(statfout, "gpu_rt_fills = %lld\n", gpu_rt_fills);
  fprintf(statfout, "gpu_st_fills_hits = %lld\n", gpu_st_fills_hits);
  fprintf(statfout, "gpu_st_fills_misses = %lld\n", gpu_st_fills_misses);
  fprintf(statfout, "gpu_rt_fills_hits = %lld\n", gpu_rt_fills_hits );
  fprintf(statfout, "gpu_rt_fills_misses = %lld\n", gpu_rt_fills_misses);

  double avg_st_entries = m_shader_stats->compue_distribution_avg(m_shader_stats->st_size_distro);
  fprintf(statfout, "avg_st_entries = %f\n", avg_st_entries);
  double avg_rt_entries = m_shader_stats->compue_distribution_avg(m_shader_stats->rt_size_distro);
  fprintf(statfout, "avg_rt_entries = %f\n", avg_rt_entries);

  m_shader_stats->print_reuse_distribution_avg();
  // performance counter for stalls due to congestion.
  fprintf(statfout, "gpu_stall_dramfull = %d\n", gpu_stall_dramfull);
  fprintf(statfout, "gpu_stall_icnt2sh    = %d\n", gpu_stall_icnt2sh);

  // printf("partiton_reqs_in_parallel = %lld\n", partiton_reqs_in_parallel);
  // printf("partiton_reqs_in_parallel_total    = %lld\n",
  // partiton_reqs_in_parallel_total );
  fprintf(statfout, "partiton_level_parallism = %12.4f\n",
         (float)partiton_reqs_in_parallel / gpu_sim_cycle);
  fprintf(statfout, "partiton_level_parallism_total  = %12.4f\n",
         (float)(partiton_reqs_in_parallel + partiton_reqs_in_parallel_total) /
             (gpu_tot_sim_cycle + gpu_sim_cycle));
  // printf("partiton_reqs_in_parallel_util = %lld\n",
  // partiton_reqs_in_parallel_util);
  // printf("partiton_reqs_in_parallel_util_total    = %lld\n",
  // partiton_reqs_in_parallel_util_total ); printf("gpu_sim_cycle_parition_util
  // = %lld\n", gpu_sim_cycle_parition_util);
  // printf("gpu_tot_sim_cycle_parition_util    = %lld\n",
  // gpu_tot_sim_cycle_parition_util );
  printf("partiton_level_parallism_util = %12.4f\n",
         (float)partiton_reqs_in_parallel_util / gpu_sim_cycle_parition_util);
  printf("partiton_level_parallism_util_total  = %12.4f\n",
         (float)(partiton_reqs_in_parallel_util +
                 partiton_reqs_in_parallel_util_total) /
             (gpu_sim_cycle_parition_util + gpu_tot_sim_cycle_parition_util));
  // printf("partiton_replys_in_parallel = %lld\n",
  // partiton_replys_in_parallel); printf("partiton_replys_in_parallel_total =
  // %lld\n", partiton_replys_in_parallel_total );
  printf("L2_BW  = %12.4f GB/Sec\n",
         ((float)(partiton_replys_in_parallel * 32) /
          (gpu_sim_cycle * m_config.icnt_period)) /
             1000000000);
  printf("L2_BW_total  = %12.4f GB/Sec\n",
         ((float)((partiton_replys_in_parallel +
                   partiton_replys_in_parallel_total) *
                  32) /
          ((gpu_tot_sim_cycle + gpu_sim_cycle) * m_config.icnt_period)) /
             1000000000);

  time_t curr_time;
  time(&curr_time);
  unsigned long long elapsed_time =
      MAX(curr_time - gpgpu_ctx->the_gpgpusim->g_simulation_starttime, 1);
  fprintf(statfout, "gpu_total_sim_rate=%u\n",
         (unsigned)((gpu_tot_sim_insn + gpu_sim_insn) / elapsed_time));

  // shader_print_l1_miss_stat( stdout );
  shader_print_cache_stats(statfout);
  fflush(statfout);

  cache_stats core_cache_stats;
  core_cache_stats.clear();
  for (unsigned i = 0; i < m_config.num_cluster(); i++) {
    m_cluster[i]->get_cache_stats(core_cache_stats);
  }
  fprintf(statfout, "\nTotal_core_cache_stats:\n");
  core_cache_stats.print_stats(statfout, "Total_core_cache_stats_breakdown");
  fprintf(statfout, "\nTotal_core_cache_fail_stats:\n");
  core_cache_stats.print_fail_stats(statfout,
                                    "Total_core_cache_fail_stats_breakdown");
  shader_print_scheduler_stat(statfout, false);

  m_shader_stats->print(statfout);
#ifdef GPGPUSIM_POWER_MODEL
  if (m_config.g_power_simulation_enabled) {
    m_gpgpusim_wrapper->print_power_kernel_stats(
        gpu_sim_cycle, gpu_tot_sim_cycle, gpu_tot_sim_insn + gpu_sim_insn,
        kernel_info_str, true);
    mcpat_reset_perf_count(m_gpgpusim_wrapper);
  }
#endif

  // performance counter that are not local to one shader
  m_memory_stats->memlatstat_print(m_memory_config->m_n_mem,
                                   m_memory_config->nbk);
  for (unsigned i = 0; i < m_memory_config->m_n_mem; i++)
    m_memory_partition_unit[i]->print(statfout);

  // L2 cache stats
  if (!m_memory_config->m_L2_config.disabled()) {
    cache_stats l2_stats;
    struct cache_sub_stats l2_css;
    struct cache_sub_stats total_l2_css;
    l2_stats.clear();
    l2_css.clear();
    total_l2_css.clear();

    fprintf(statfout, "\n========= L2 cache stats =========\n");
    for (unsigned i = 0; i < m_memory_config->m_n_mem_sub_partition; i++) {
      m_memory_sub_partition[i]->accumulate_L2cache_stats(l2_stats);
      m_memory_sub_partition[i]->get_L2cache_sub_stats(l2_css);

      fprintf(statfout,
              "L2_cache_bank[%d]: Access = %llu, Miss = %llu, Miss_rate = "
              "%.3lf, Pending_hits = %llu, Reservation_fails = %llu\n",
              i, l2_css.accesses, l2_css.misses,
              (double)l2_css.misses / (double)l2_css.accesses,
              l2_css.pending_hits, l2_css.res_fails);

      total_l2_css += l2_css;
    }
    fflush(statfout);
    if (!m_memory_config->m_L2_config.disabled() &&
        m_memory_config->m_L2_config.get_num_lines()) {
      // L2c_print_cache_stat();
      fprintf(statfout, "L2_total_cache_accesses = %llu\n", total_l2_css.accesses);
      fprintf(statfout, "L2_total_cache_misses = %llu\n", total_l2_css.misses);
      if (total_l2_css.accesses > 0)
        fprintf(statfout, "L2_total_cache_miss_rate = %.4lf\n",
               (double)total_l2_css.misses / (double)total_l2_css.accesses);
      fprintf(statfout, "L2_total_cache_pending_hits = %llu\n", total_l2_css.pending_hits);
      fprintf(statfout, "L2_total_cache_reservation_fails = %llu\n",
             total_l2_css.res_fails);
      fprintf(statfout, "L2_total_cache_breakdown:\n");
      l2_stats.print_stats(statfout, "L2_cache_stats_breakdown");
      fprintf(statfout, "L2_total_cache_reservation_fail_breakdown:\n");
      l2_stats.print_fail_stats(statfout, "L2_cache_stats_fail_breakdown");
      total_l2_css.print_port_stats(statfout, "L2_cache");
    }
  }

  if (m_config.gpgpu_cflog_interval != 0) {
    spill_log_to_file(statfout, 1, gpu_sim_cycle);
    insn_warp_occ_print(statfout);
  }
  if (gpgpu_ctx->func_sim->gpgpu_ptx_instruction_classification) {
    StatDisp(gpgpu_ctx->func_sim->g_inst_classification_stat
                 [gpgpu_ctx->func_sim->g_ptx_kernel_count]);
    StatDisp(gpgpu_ctx->func_sim->g_inst_op_classification_stat
                 [gpgpu_ctx->func_sim->g_ptx_kernel_count]);
  }
    
  fprintf(statfout, "Ray tracing memory access distribution: \n");
  for (unsigned i=0; i<static_cast<int>(TransactionType::UNDEFINED); i++) {
      fprintf(statfout, "%d\t", gpgpu_ctx->func_sim->g_rt_mem_access_type[i]);
  }
  fprintf(statfout, "\n");

  fprintf(statfout, "rt_num_hits = %d\n", gpgpu_ctx->func_sim->g_rt_num_hits);
  fprintf(statfout, "rt_num_any_hits = %d\n", gpgpu_ctx->func_sim->g_rt_num_any_hits);
  fprintf(statfout, "rt_n_anyhit_rays = %d\n", gpgpu_ctx->func_sim->g_n_anyhit_rays);
  fprintf(statfout, "rt_n_closesthit_rays = %d\n", gpgpu_ctx->func_sim->g_n_closesthit_rays);
  fprintf(statfout, "rt_n_total_rays = %d\n", gpgpu_ctx->func_sim->g_n_closesthit_rays + gpgpu_ctx->func_sim->g_n_anyhit_rays);
  fprintf(statfout, "rt_max_tree_depth = %d\n", gpgpu_ctx->func_sim->g_max_tree_depth);
  fprintf(statfout, "rt_max_nodes_per_ray = %d\n", gpgpu_ctx->func_sim->g_max_nodes_per_ray);
  fprintf(statfout, "rt_tot_nodes_per_ray = %d\n", gpgpu_ctx->func_sim->g_tot_nodes_per_ray);
  fprintf(statfout, "rt_avg_nodes_per_ray = %f\n", (float)gpgpu_ctx->func_sim->g_tot_nodes_per_ray/(gpgpu_ctx->func_sim->g_n_closesthit_rays + gpgpu_ctx->func_sim->g_n_anyhit_rays));
  fprintf(statfout, "g_inst_type_latency = ");
  for (unsigned i=0; i<28; i++) {
    fprintf(statfout, "%lld ", gpgpu_ctx->func_sim->g_inst_type_latency[i]);
  }
  fprintf(statfout, "\n");
  fprintf(statfout, "inst_class_by_shader\n");
  for (unsigned i=0; i<16; i++) {
    fprintf(statfout, "%d:", i);
    for (unsigned j=0; j<20; j++) {
      fprintf(statfout, "%d\t", gpgpu_ctx->func_sim->g_inst_class_stat[i][j]);
    }
    fprintf(statfout, "\n");
  }

#ifdef GPGPUSIM_POWER_MODEL
  if (m_config.g_power_simulation_enabled) {
    m_gpgpusim_wrapper->detect_print_steady_state(
        1, gpu_tot_sim_insn + gpu_sim_insn);
  }
#endif

  // Interconnect power stat print
  long total_simt_to_mem = 0;
  long total_mem_to_simt = 0;
  long temp_stm = 0;
  long temp_mts = 0;
  for (unsigned i = 0; i < m_config.num_cluster(); i++) {
    m_cluster[i]->get_icnt_stats(temp_stm, temp_mts);
    total_simt_to_mem += temp_stm;
    total_mem_to_simt += temp_mts;
  }
  fprintf(statfout, "\nicnt_total_pkts_mem_to_simt=%ld\n", total_mem_to_simt);
  fprintf(statfout, "icnt_total_pkts_simt_to_mem=%ld\n", total_simt_to_mem);

  time_vector_print();
  fflush(statfout);

  clear_executed_kernel_info();
}

// performance counter that are not local to one shader
unsigned gpgpu_sim::threads_per_core() const {
  return m_shader_config->n_thread_per_shader;
}

void shader_core_ctx::mem_instruction_stats(const warp_inst_t &inst) {
  unsigned active_count = inst.active_count();
  // this breaks some encapsulation: the is_[space] functions, if you change
  // those, change this.
  switch (inst.space.get_type()) {
    case undefined_space:
    case reg_space:
      break;
    case shared_space:
      m_stats->gpgpu_n_shmem_insn += active_count;
      break;
    case sstarr_space:
      m_stats->gpgpu_n_sstarr_insn += active_count;
      break;
    case const_space:
      m_stats->gpgpu_n_const_insn += active_count;
      break;
    case param_space_kernel:
    case param_space_local:
      m_stats->gpgpu_n_param_insn += active_count;
      break;
    case tex_space:
      m_stats->gpgpu_n_tex_insn += active_count;
      break;
    case global_space:
      if (inst.is_store())
        m_stats->gpgpu_n_global_store_insn += active_count;
      else
        m_stats->gpgpu_n_global_load_insn += active_count;
      break;
    case local_space:
      if (inst.is_store())
        m_stats->gpgpu_n_local_store_insn += active_count;
      else
        m_stats->gpgpu_n_local_load_insn += active_count;
      break;
    default:
      abort();
  }
}

void shader_core_ctx::rt_mem_instruction_stats(const warp_inst_t &inst) {
  unsigned active_count = inst.active_count();
  m_stats->gpgpu_n_rt_insn += active_count;

  for (unsigned i=0; i<m_config->warp_size; i++) {
    m_stats->gpgpu_n_rt_access_insn += inst.mem_list_length(i);
  }
}

bool shader_core_ctx::can_issue_1block(kernel_info_t &kernel) {
  // Jin: concurrent kernels on one SM
  if (m_config->gpgpu_concurrent_kernel_sm) {
    if (m_config->max_cta(kernel) < 1) return false;

    return occupy_shader_resource_1block(kernel, false);
  } else {
    if(m_gpu->gpgpu_ctx->device_runtime->g_custom_cta_scheduling) {
      int num_cta_groups = kernel.num_blocks() / (m_gpu->gpgpu_ctx->device_runtime->g_cta_group_size);
      return (get_n_active_cta() < m_config->max_cta(kernel)) && ((static_cta_schedule[cta_group_idx[m_sid]].size() > 0) || next_cta_group_idx != num_cta_groups);
    }
    else
      return (get_n_active_cta() < m_config->max_cta(kernel));
  }
}

int shader_core_ctx::find_available_hwtid(unsigned int cta_size, bool occupy) {
  unsigned int step;
  for (step = 0; step < m_config->n_thread_per_shader; step += cta_size) {
    unsigned int hw_tid;
    for (hw_tid = step; hw_tid < step + cta_size; hw_tid++) {
      if (m_occupied_hwtid.test(hw_tid)) break;
    }
    if (hw_tid == step + cta_size)  // consecutive non-active
      break;
  }
  if (step >= m_config->n_thread_per_shader)  // didn't find
    return -1;
  else {
    if (occupy) {
      for (unsigned hw_tid = step; hw_tid < step + cta_size; hw_tid++)
        m_occupied_hwtid.set(hw_tid);
    }
    return step;
  }
}

bool shader_core_ctx::occupy_shader_resource_1block(kernel_info_t &k,
                                                    bool occupy) {
  unsigned threads_per_cta = k.threads_per_cta();
  const class function_info *kernel = k.entry();
  unsigned int padded_cta_size = threads_per_cta;
  unsigned int warp_size = m_config->warp_size;
  if (padded_cta_size % warp_size)
    padded_cta_size = ((padded_cta_size / warp_size) + 1) * (warp_size);

  if (m_occupied_n_threads + padded_cta_size > m_config->n_thread_per_shader)
    return false;

  if (find_available_hwtid(padded_cta_size, false) == -1) return false;

  const struct gpgpu_ptx_sim_info *kernel_info = ptx_sim_kernel_info(kernel);

  if (m_occupied_shmem + kernel_info->smem > m_config->gpgpu_shmem_size)
    return false;

  unsigned int used_regs = padded_cta_size * ((kernel_info->regs + 3) & ~3);
  if (m_occupied_regs + used_regs > m_config->gpgpu_shader_registers)
    return false;

  if (m_occupied_ctas + 1 > m_config->max_cta_per_core) return false;

  if (occupy) {
    m_occupied_n_threads += padded_cta_size;
    m_occupied_shmem += kernel_info->smem;
    m_occupied_regs += (padded_cta_size * ((kernel_info->regs + 3) & ~3));
    m_occupied_ctas++;

    SHADER_DPRINTF(LIVENESS,
                   "GPGPU-Sim uArch: Occupied %u threads, %u shared mem, %u "
                   "registers, %u ctas\n",
                   m_occupied_n_threads, m_occupied_shmem, m_occupied_regs,
                   m_occupied_ctas);
  }

  return true;
}

void shader_core_ctx::release_shader_resource_1block(unsigned hw_ctaid,
                                                     kernel_info_t &k) {
  if (m_config->gpgpu_concurrent_kernel_sm) {
    unsigned threads_per_cta = k.threads_per_cta();
    const class function_info *kernel = k.entry();
    unsigned int padded_cta_size = threads_per_cta;
    unsigned int warp_size = m_config->warp_size;
    if (padded_cta_size % warp_size)
      padded_cta_size = ((padded_cta_size / warp_size) + 1) * (warp_size);

    assert(m_occupied_n_threads >= padded_cta_size);
    m_occupied_n_threads -= padded_cta_size;

    int start_thread = m_occupied_cta_to_hwtid[hw_ctaid];

    for (unsigned hwtid = start_thread; hwtid < start_thread + padded_cta_size;
         hwtid++)
      m_occupied_hwtid.reset(hwtid);
    m_occupied_cta_to_hwtid.erase(hw_ctaid);

    const struct gpgpu_ptx_sim_info *kernel_info = ptx_sim_kernel_info(kernel);

    assert(m_occupied_shmem >= (unsigned int)kernel_info->smem);
    m_occupied_shmem -= kernel_info->smem;

    unsigned int used_regs = padded_cta_size * ((kernel_info->regs + 3) & ~3);
    assert(m_occupied_regs >= used_regs);
    m_occupied_regs -= used_regs;

    assert(m_occupied_ctas >= 1);
    m_occupied_ctas--;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Launches a cooperative thread array (CTA).
 *
 * @param kernel
 *    object that tells us which kernel to ask for a CTA from
 */

unsigned exec_shader_core_ctx::sim_init_thread(
    kernel_info_t &kernel, ptx_thread_info **thread_info, int sid, unsigned tid,
    unsigned threads_left, unsigned num_threads, core_t *core,
    unsigned hw_cta_id, unsigned hw_warp_id, gpgpu_t *gpu, unsigned kernel_cta_id) {
  return ptx_sim_init_thread(kernel, thread_info, sid, tid, threads_left,
                             num_threads, core, hw_cta_id, hw_warp_id, gpu, kernel_cta_id);
}

void shader_core_ctx::issue_block2core(kernel_info_t &kernel) {
  if (!m_config->gpgpu_concurrent_kernel_sm)
    set_max_cta(kernel);
  else
    assert(occupy_shader_resource_1block(kernel, true));

  kernel.inc_running();

  // find a free CTA context
  unsigned free_cta_hw_id = (unsigned)-1;

  unsigned max_cta_per_core;
  if (!m_config->gpgpu_concurrent_kernel_sm)
    max_cta_per_core = kernel_max_cta_per_shader;
  else
    max_cta_per_core = m_config->max_cta_per_core;
  for (unsigned i = 0; i < max_cta_per_core; i++) {
    if (m_cta_status[i] == 0) {
      free_cta_hw_id = i;
      break;
    }
  }
  assert(free_cta_hw_id != (unsigned)-1);

  // determine hardware threads and warps that will be used for this CTA
  int cta_size = kernel.threads_per_cta();

  // hw warp id = hw thread id mod warp size, so we need to find a range
  // of hardware thread ids corresponding to an integral number of hardware
  // thread ids
  int padded_cta_size = cta_size;
  if (cta_size % m_config->warp_size)
    padded_cta_size =
        ((cta_size / m_config->warp_size) + 1) * (m_config->warp_size);

  unsigned int start_thread, end_thread;

  if (!m_config->gpgpu_concurrent_kernel_sm) {
    start_thread = free_cta_hw_id * padded_cta_size;
    end_thread = start_thread + cta_size;
  } else {
    start_thread = find_available_hwtid(padded_cta_size, true);
    assert((int)start_thread != -1);
    end_thread = start_thread + cta_size;
    assert(m_occupied_cta_to_hwtid.find(free_cta_hw_id) ==
           m_occupied_cta_to_hwtid.end());
    m_occupied_cta_to_hwtid[free_cta_hw_id] = start_thread;
  }

  // reset the microarchitecture state of the selected hardware thread and warp
  // contexts
  reinit(start_thread, end_thread, false);

  // initalize scalar threads and determine which hardware warps they are
  // allocated to bind functional simulation state of threads to hardware
  // resources (simulation)
  warp_set_t warps;
  unsigned nthreads_in_block = 0;
  function_info *kernel_func_info = kernel.entry();
  symbol_table *symtab = kernel_func_info->get_symtab();
  unsigned ctaid;
  if(!m_gpu->gpgpu_ctx->device_runtime->g_custom_cta_scheduling)
    ctaid = kernel.get_next_cta_id_single();
  else {
    if(static_cta_schedule[cta_group_idx[m_sid]].size() > 0) {
      ctaid = static_cta_schedule[cta_group_idx[m_sid]][0];
      static_cta_schedule[cta_group_idx[m_sid]].erase(static_cta_schedule[cta_group_idx[m_sid]].begin());
    }
    else {
      assert(next_cta_group_idx != kernel.num_blocks() / (m_gpu->gpgpu_ctx->device_runtime->g_cta_group_size));
      cta_group_idx[m_sid] = next_cta_group_idx;
      next_cta_group_idx++;
      ctaid = static_cta_schedule[cta_group_idx[m_sid]][0];
      static_cta_schedule[cta_group_idx[m_sid]].erase(static_cta_schedule[cta_group_idx[m_sid]].begin());
    }
  }

  checkpoint *g_checkpoint = new checkpoint();
  for (unsigned i = start_thread; i < end_thread; i++) {
    m_threadState[i].m_cta_id = free_cta_hw_id;
    unsigned warp_id = i / m_config->warp_size;
    nthreads_in_block += sim_init_thread(
        kernel, &m_thread[i], m_sid, i, cta_size - (i - start_thread),
        m_config->n_thread_per_shader, this, free_cta_hw_id, warp_id,
        m_cluster->get_gpu(),ctaid);
    m_threadState[i].m_active = true;
    // load thread local memory and register file
    if (m_gpu->resume_option == 1 && kernel.get_uid() == m_gpu->resume_kernel &&
        ctaid >= m_gpu->resume_CTA && ctaid < m_gpu->checkpoint_CTA_t) {
      char fname[2048];
      snprintf(fname, 2048, "checkpoint_files/thread_%d_%d_reg.txt",
               i % cta_size, ctaid);
      m_thread[i]->resume_reg_thread(fname, symtab);
      char f1name[2048];
      snprintf(f1name, 2048, "checkpoint_files/local_mem_thread_%d_%d_reg.txt",
               i % cta_size, ctaid);
      g_checkpoint->load_global_mem(m_thread[i]->m_local_mem, f1name);
    }
    //
    warps.set(warp_id);
  }
  assert(nthreads_in_block > 0 &&
         nthreads_in_block <=
             m_config->n_thread_per_shader);  // should be at least one, but
                                              // less than max
  m_cta_status[free_cta_hw_id] = nthreads_in_block;

  if (m_gpu->resume_option == 1 && kernel.get_uid() == m_gpu->resume_kernel &&
      ctaid >= m_gpu->resume_CTA && ctaid < m_gpu->checkpoint_CTA_t) {
    char f1name[2048];
    snprintf(f1name, 2048, "checkpoint_files/shared_mem_%d.txt", ctaid);

    g_checkpoint->load_global_mem(m_thread[start_thread]->m_shared_mem, f1name);
  }
  // now that we know which warps are used in this CTA, we can allocate
  // resources for use in CTA-wide barrier operations
  m_barriers.allocate_barrier(free_cta_hw_id, warps);

  // initialize the SIMT stacks and fetch hardware
  init_warps(free_cta_hw_id, start_thread, end_thread, ctaid, cta_size, kernel);
  m_n_active_cta++;
  printf("Issued cta %d to sm %d at cycle: %llu\n", ctaid, m_sid, m_gpu->gpu_sim_cycle);
  shader_CTA_count_log(m_sid, 1);
  SHADER_DPRINTF(LIVENESS,
                 "GPGPU-Sim uArch: cta:%2u, start_tid:%4u, end_tid:%4u, "
                 "initialized @(%lld,%lld)\n",
                 free_cta_hw_id, start_thread, end_thread, m_gpu->gpu_sim_cycle,
                 m_gpu->gpu_tot_sim_cycle);
}

///////////////////////////////////////////////////////////////////////////////////////////

void dram_t::dram_log(int task) {
  if (task == SAMPLELOG) {
    StatAddSample(mrqq_Dist, que_length());
  } else if (task == DUMPLOG) {
    printf("Queue Length DRAM[%d] ", id);
    StatDisp(mrqq_Dist);
  }
}

// Find next clock domain and increment its time
int gpgpu_sim::next_clock_domain(void) {
  double smallest = min3(core_time, icnt_time, dram_time);
  int mask = 0x00;
  if (l2_time <= smallest) {
    smallest = l2_time;
    mask |= L2;
    l2_time += m_config.l2_period;
  }
  if (icnt_time <= smallest) {
    mask |= ICNT;
    icnt_time += m_config.icnt_period;
  }
  if (dram_time <= smallest) {
    mask |= DRAM;
    dram_time += m_config.dram_period;
  }
  if (core_time <= smallest) {
    mask |= CORE;
    core_time += m_config.core_period;
  }
  return mask;
}

void gpgpu_sim::issue_block2core() {
  unsigned last_issued = m_last_cluster_issue;
  for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
    unsigned idx = (i + last_issued + 1) % m_shader_config->n_simt_clusters;
    unsigned num = m_cluster[idx]->issue_block2core();
    if (num) {
      m_last_cluster_issue = idx;
      m_total_cta_launched += num;
    }
  }
}

unsigned long long g_single_step =
    0;  // set this in gdb to single step the pipeline

void gpgpu_sim::cycle() {
  int clock_mask = next_clock_domain();

  if (clock_mask & CORE) {
    // shader core loading (pop from ICNT into core) follows CORE clock
    for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++)
      m_cluster[i]->icnt_cycle();
  }
  unsigned partiton_replys_in_parallel_per_cycle = 0;
  if (clock_mask & ICNT) {
    // pop from memory controller to interconnect
    for (unsigned i = 0; i < m_memory_config->m_n_mem_sub_partition; i++) {
      mem_fetch *mf = m_memory_sub_partition[i]->top();
      if (mf) {
        unsigned response_size =
            mf->get_is_write() ? mf->get_ctrl_size() : mf->size();
        if (::icnt_has_buffer(m_shader_config->mem2device(i), response_size)) {
          // if (!mf->get_is_write())
          mf->set_return_timestamp(gpu_sim_cycle + gpu_tot_sim_cycle);
          mf->set_status(IN_ICNT_TO_SHADER, gpu_sim_cycle + gpu_tot_sim_cycle);
          ::icnt_push(m_shader_config->mem2device(i), mf->get_tpc(), mf,
                      response_size);
          m_memory_sub_partition[i]->pop();
          partiton_replys_in_parallel_per_cycle++;
        } else {
          gpu_stall_icnt2sh++;
        }
      } else {
        m_memory_sub_partition[i]->pop();
      }
    }
  }
  partiton_replys_in_parallel += partiton_replys_in_parallel_per_cycle;

  if (clock_mask & DRAM) {
    for (unsigned i = 0; i < m_memory_config->m_n_mem; i++) {
      if (m_memory_config->simple_dram_model)
        m_memory_partition_unit[i]->simple_dram_model_cycle();
      else
        m_memory_partition_unit[i]
            ->dram_cycle();  // Issue the dram command (scheduler + delay model)
      // Update performance counters for DRAM
      m_memory_partition_unit[i]->set_dram_power_stats(
          m_power_stats->pwr_mem_stat->n_cmd[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_activity[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_nop[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_act[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_pre[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_rd[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_wr[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_req[CURRENT_STAT_IDX][i]);
    }
  }

  // L2 operations follow L2 clock domain
  unsigned partiton_reqs_in_parallel_per_cycle = 0;
  if (clock_mask & L2) {
    m_power_stats->pwr_mem_stat->l2_cache_stats[CURRENT_STAT_IDX].clear();
    for (unsigned i = 0; i < m_memory_config->m_n_mem_sub_partition; i++) {
      // move memory request from interconnect into memory partition (if not
      // backed up) Note:This needs to be called in DRAM clock domain if there
      // is no L2 cache in the system In the worst case, we may need to push
      // SECTOR_CHUNCK_SIZE requests, so ensure you have enough buffer for them
      if (m_memory_sub_partition[i]->full(SECTOR_CHUNCK_SIZE)) {
        gpu_stall_dramfull++;
      } else {
        mem_fetch *mf = (mem_fetch *)icnt_pop(m_shader_config->mem2device(i));
        m_memory_sub_partition[i]->push(mf, gpu_sim_cycle + gpu_tot_sim_cycle);
        if (mf) partiton_reqs_in_parallel_per_cycle++;
      }
      m_memory_sub_partition[i]->cache_cycle(gpu_sim_cycle + gpu_tot_sim_cycle);
      m_memory_sub_partition[i]->accumulate_L2cache_stats(
          m_power_stats->pwr_mem_stat->l2_cache_stats[CURRENT_STAT_IDX]);
    }
  }
  partiton_reqs_in_parallel += partiton_reqs_in_parallel_per_cycle;
  if (partiton_reqs_in_parallel_per_cycle > 0) {
    partiton_reqs_in_parallel_util += partiton_reqs_in_parallel_per_cycle;
    gpu_sim_cycle_parition_util++;
  }

  if (clock_mask & ICNT) {
    icnt_transfer();
  }

  if (clock_mask & CORE) {
    // L1 cache + shader core pipeline stages
    m_power_stats->pwr_mem_stat->core_cache_stats[CURRENT_STAT_IDX].clear();
    for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
      if (m_cluster[i]->get_not_completed() || get_more_cta_left()) {
        m_cluster[i]->core_cycle();
        *active_sms += m_cluster[i]->get_n_active_sms();
      }
      // Update core icnt/cache stats for GPUWattch
      m_cluster[i]->get_icnt_stats(
          m_power_stats->pwr_mem_stat->n_simt_to_mem[CURRENT_STAT_IDX][i],
          m_power_stats->pwr_mem_stat->n_mem_to_simt[CURRENT_STAT_IDX][i]);
      m_cluster[i]->get_cache_stats(
          m_power_stats->pwr_mem_stat->core_cache_stats[CURRENT_STAT_IDX]);
      m_cluster[i]->get_current_occupancy(
          gpu_occupancy.aggregate_warp_slot_filled,
          gpu_occupancy.aggregate_theoretical_warp_slots);
    }
    float temp = 0;
    for (unsigned i = 0; i < m_shader_config->num_shader(); i++) {
      temp += m_shader_stats->m_pipeline_duty_cycle[i];
    }
    temp = temp / m_shader_config->num_shader();
    *average_pipeline_duty_cycle = ((*average_pipeline_duty_cycle) + temp);
    // cout<<"Average pipeline duty cycle:
    // "<<*average_pipeline_duty_cycle<<endl;

    if (g_single_step &&
        ((gpu_sim_cycle + gpu_tot_sim_cycle) >= g_single_step)) {
      raise(SIGTRAP);  // Debug breakpoint
    }
    gpu_sim_cycle++;

    if (g_interactive_debugger_enabled) gpgpu_debug();

      // McPAT main cycle (interface with McPAT)
#ifdef GPGPUSIM_POWER_MODEL
    if (m_config.g_power_simulation_enabled) {
      mcpat_cycle(m_config, getShaderCoreConfig(), m_gpgpusim_wrapper,
                  m_power_stats, m_config.gpu_stat_sample_freq,
                  gpu_tot_sim_cycle, gpu_sim_cycle, gpu_tot_sim_insn,
                  gpu_sim_insn);
    }
#endif

    issue_block2core();
    decrement_kernel_latency();

    // Depending on configuration, invalidate the caches once all of threads are
    // completed.
    int all_threads_complete = 1;
    if (m_config.gpgpu_flush_l1_cache) {
      for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
        if (m_cluster[i]->get_not_completed() == 0)
          m_cluster[i]->cache_invalidate();
        else
          all_threads_complete = 0;
      }
    }

    if (m_config.gpgpu_flush_l2_cache) {
      if (!m_config.gpgpu_flush_l1_cache) {
        for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
          if (m_cluster[i]->get_not_completed() != 0) {
            all_threads_complete = 0;
            break;
          }
        }
      }

      if (all_threads_complete && !m_memory_config->m_L2_config.disabled()) {
        printf("Flushed L2 caches...\n");
        if (m_memory_config->m_L2_config.get_num_lines()) {
          int dlc = 0;
          for (unsigned i = 0; i < m_memory_config->m_n_mem; i++) {
            dlc = m_memory_sub_partition[i]->flushL2();
            assert(dlc == 0);  // TODO: need to model actual writes to DRAM here
            printf("Dirty lines flushed from L2 %d is %d\n", i, dlc);
          }
        }
      }
    }

    if (!(gpu_sim_cycle % m_config.gpu_stat_sample_freq)) {
      time_t days, hrs, minutes, sec;
      time_t curr_time;
      time(&curr_time);
      unsigned long long elapsed_time =
          MAX(curr_time - gpgpu_ctx->the_gpgpusim->g_simulation_starttime, 1);
      if ((elapsed_time - last_liveness_message_time) >=
              m_config.liveness_message_freq &&
          DTRACE(LIVENESS)) {
        days = elapsed_time / (3600 * 24);
        hrs = elapsed_time / 3600 - 24 * days;
        minutes = elapsed_time / 60 - 60 * (hrs + 24 * days);
        sec = elapsed_time - 60 * (minutes + 60 * (hrs + 24 * days));

        unsigned long long active = 0, total = 0;
        for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
          m_cluster[i]->get_current_occupancy(active, total);
        }
        DPRINTFG(LIVENESS,
                 "uArch: inst.: %lld (ipc=%4.1f, occ=%0.4f\% [%llu / %llu]) "
                 "sim_rate=%u (inst/sec) elapsed = %u:%u:%02u:%02u / %s",
                 gpu_tot_sim_insn + gpu_sim_insn,
                 (double)gpu_sim_insn / (double)gpu_sim_cycle,
                 float(active) / float(total) * 100, active, total,
                 (unsigned)((gpu_tot_sim_insn + gpu_sim_insn) / elapsed_time),
                 (unsigned)days, (unsigned)hrs, (unsigned)minutes,
                 (unsigned)sec, ctime(&curr_time));
        fflush(stdout);
        last_liveness_message_time = elapsed_time;
      }
      visualizer_printstat();
      m_memory_stats->memlatstat_lat_pw();
      if (m_config.gpgpu_runtime_stat &&
          (m_config.gpu_runtime_stat_flag != 0)) {
        if (m_config.gpu_runtime_stat_flag & GPU_RSTAT_BW_STAT) {
          for (unsigned i = 0; i < m_memory_config->m_n_mem; i++)
            m_memory_partition_unit[i]->print_stat(stdout);
          printf("maxmrqlatency = %d \n", m_memory_stats->max_mrq_latency);
          printf("maxmflatency = %d \n", m_memory_stats->max_mf_latency);
        }
        if (m_config.gpu_runtime_stat_flag & GPU_RSTAT_SHD_INFO)
          shader_print_runtime_stat(stdout);
        if (m_config.gpu_runtime_stat_flag & GPU_RSTAT_L1MISS)
          shader_print_l1_miss_stat(stdout);
        if (m_config.gpu_runtime_stat_flag & GPU_RSTAT_SCHED)
          shader_print_scheduler_stat(stdout, false);
      }
    }

    if (!(gpu_sim_cycle % 300000)) {
      // deadlock detection
      if (m_config.gpu_deadlock_detect && gpu_sim_insn == last_gpu_sim_insn) {
        gpu_deadlock = true;
      } else {
        last_gpu_sim_insn = gpu_sim_insn;
      }
    }
    try_snap_shot(gpu_sim_cycle);
    spill_log_to_file(stdout, 0, gpu_sim_cycle);

#if (CUDART_VERSION >= 5000)
    // launch device kernel
    gpgpu_ctx->device_runtime->launch_one_device_kernel();
#endif
  }
}

void shader_core_ctx::dump_warp_state(FILE *fout) const {
  fprintf(fout, "\n");
  fprintf(fout, "per warp functional simulation status:\n");
  for (unsigned w = 0; w < m_config->max_warps_per_shader; w++)
    m_warp[w]->print(fout);
}

void gpgpu_sim::perf_memcpy_to_gpu(size_t dst_start_addr, size_t count) {
  if (m_memory_config->m_perf_sim_memcpy) {
    // if(!m_config.trace_driven_mode)    //in trace-driven mode, CUDA runtime
    // can start nre data structure at any position 	assert (dst_start_addr %
    // 32
    //== 0);

    for (unsigned counter = 0; counter < count; counter += 32) {
      const unsigned wr_addr = dst_start_addr + counter;
      addrdec_t raw_addr;
      mem_access_sector_mask_t mask;
      mask.set(wr_addr % 128 / 32);
      m_memory_config->m_address_mapping.addrdec_tlx(wr_addr, &raw_addr);
      const unsigned partition_id =
          raw_addr.sub_partition /
          m_memory_config->m_n_sub_partition_per_memory_channel;
      m_memory_partition_unit[partition_id]->handle_memcpy_to_gpu(
          wr_addr, raw_addr.sub_partition, mask);
    }
  }
}

void gpgpu_sim::dump_rt_pipeline(int sid) const {
  printf("Dumping RT core pipeline state...\n");
  m_cluster[m_shader_config->sid_to_cluster(sid)]->display_rt_pipeline(
          sid, stdout, 0x40 & 0x2E);
}

void gpgpu_sim::dump_pipeline(int mask, int s, int m) const {
  /*
     You may want to use this function while running GPGPU-Sim in gdb.
     One way to do that is add the following to your .gdbinit file:

        define dp
           call g_the_gpu.dump_pipeline_impl((0x40|0x4|0x1),$arg0,0)
        end

     Then, typing "dp 3" will show the contents of the pipeline for shader
     core 3.
  */

  printf("Dumping pipeline state...\n");
  if (!mask) mask = 0xFFFFFFFF;
  for (unsigned i = 0; i < m_shader_config->n_simt_clusters; i++) {
    if (s != -1) {
      i = s;
    }
    if (mask & 1)
      m_cluster[m_shader_config->sid_to_cluster(i)]->display_pipeline(
          i, stdout, 1, mask & 0x2E);
    if (s != -1) {
      break;
    }
  }
  if (mask & 0x10000) {
    for (unsigned i = 0; i < m_memory_config->m_n_mem; i++) {
      if (m != -1) {
        i = m;
      }
      printf("DRAM / memory controller %u:\n", i);
      if (mask & 0x100000) m_memory_partition_unit[i]->print_stat(stdout);
      if (mask & 0x1000000) m_memory_partition_unit[i]->visualize();
      if (mask & 0x10000000) m_memory_partition_unit[i]->print(stdout);
      if (m != -1) {
        break;
      }
    }
  }
  fflush(stdout);
}

const shader_core_config *gpgpu_sim::getShaderCoreConfig() {
  return m_shader_config;
}

const memory_config *gpgpu_sim::getMemoryConfig() { return m_memory_config; }

simt_core_cluster *gpgpu_sim::getSIMTCluster() { return *m_cluster; }
